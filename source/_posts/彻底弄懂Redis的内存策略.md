---
title: 彻底弄懂Redis的内存策略
date: 2023-08-08 11:05:02
tags: Redis
---

## Redis内存策略

Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响持久化或主从同步性能。
我们可以通过修改配置文件来设置Redis的最大内存：

![img](../pic/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/1689684101459-fcfd7925-0b58-44a2-b0c6-929770abd05e.png)

当内存使用达到上限时，就无法存储更多数据了

### 内存过期策略

在学习Redis缓存的时候我们说过，可以通过expire命令给Redis的key设置TTL（存活时间）：

![img](../pic/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/1689684101533-4e197692-0635-480c-88a4-ecf2675d8542.png)

可以发现，当key的TTL到期以后，再次访问name返回的是nil，说明这个key已经不存在了，对应的内存也得到释放。从而起到内存回收的目的。

这里其实之前我们没有想过：

1. Redis怎么知道一个key过期了
2. 是不是TTL过期之后就立马删除了



#### 解决第一个问题

通过两个dict分别存储key-value和key-ttl

Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在之前学习过的Dict结构中。不过在其database结构体中，有两个Dict：一个用来记录key-value；另一个用来记录key-TTL。

![img](../pic/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/1691461510713-829ee299-088a-411f-a8bb-fec07ed3fc02.png)

![img](../pic/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/1691461612098-d44467bf-e6db-454d-b790-8ce7fe5ae30d.png)



#### 解决第二个问题

1. 是不是TTL到期就立即删除了呢？

1. 1. 惰性删除
   2. 周期删除 

##### 惰性删除

惰性删除：顾名思义**并不是在TTL到期后就立刻删除，而是在访问一个key的时候，检查该key的存活时间，如果已经过期才执行删除。**

![img](../pic/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/1689684101819-94f78718-8a14-430e-8500-8569d2aac994.png)



##### 周期删除

周期删除：顾明思议是通过一个定时任务，周期性的抽样部分过期的key，然后执行删除。并且这种方法会根据不同的算法，每一次都抽样不同的key进行删除，最终会删除所有的过期key，他的执行周期有两种：

- Redis服务初始化函数initServer()中设置定时任务，按照server.hz的频率来执行过期key清理，模式为SLOW
- Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST

![img](../pic/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/1690450506068-9fcb7421-6757-4709-88c8-37f1ad768692.png)



SLOW模式规则：

- 执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。
- 执行清理耗时不超过一次执行周期的25%.默认slow模式耗时不超过25ms
- 逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期
- 如果没达到时间上限（25ms）并且过期key比例大于10%，再进行一次抽样，否则结束

FAST模式规则（过期key比例小于10%不执行 ）：

- 执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms
- 执行清理耗时不超过1ms
- 逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期
- 如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束

### 内存淘汰策略

内存淘汰就是当Redis内存**使用达到设置的上限**时，主动挑选部分key删除以释放更多内存的流程。

Redis会在处理客户端命令的方法processCommand()中尝试做内存淘汰(redis会在任何命令执行之前会先判断是否内存达到了阈值，然后去执行内存清理，如果内存清理失败的话就拒绝执行这条指令，下面的代码有显示)：

![img](../pic/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/1691462614204-39ffa7aa-1367-4bae-b765-8c05510ad467.png)

**淘汰策略**

Redis支持8种不同策略来选择要删除的key：

- noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。
- volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰
- allkeys-random：对全体key ，随机进行淘汰。也就是直接从db->dict中随机挑选
- volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从db->expires中随机挑选。
- allkeys-lru： 对全体key，基于LRU算法进行淘汰
- volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰
- allkeys-lfu： 对全体key，基于LFU算法进行淘汰
- volatile-lfu： 对设置了TTL的key，基于LFI算法进行淘汰

比较容易混淆的有两个： 

- LRU（Least Recently Used），最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高（越久没被访问，越容易被淘汰）。
- LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。（在一段时间里面，被访问的次数越少，越容易被淘汰）

Redis的数据都会被封装为RedisObject结构：

![img](../pic/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/1691462969944-ba40200f-5b3a-4267-815b-6c93c5f2f0bd.png)

上图蓝框框里面提到了逻辑访问次数：LFU的访问次数之所以叫做**逻辑访问次数**，是因为并不是每次key被访问都计数，而是通过算法进行运算：

- 生成0~1之间的随机数R
- 计算 (旧次数 * lfu_log_factor + 1)，记录为P
- 如果 R < P ，则计数器 + 1，且最大不超过255
- 访问次数会随时间衰减，距离上一次访问时间每隔 lfu_decay_time 分钟，计数器 -1





在redis里面的LRU和LFU和TTL并不是遍历全部的数据，而是进行抽样，抽样出一部分数据之后放到一个淘汰池中，然后在池子里面进行比较是否是最小的，这也是由底层算法来决定的，准确率虽然比全部遍历要差一些，但是仍然是可以接收的





最后用一副图来描述当前的这个流程吧

![img](../pic/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/1689684102074-5c61df9d-bf70-4850-9fc1-975d6806e4a8.png)
