---
title: 计算机组成原理复习
date: 2023-06-13 15:14:24
tags:
---

# CPU与存储器的连接（74138译码器）

> `MREQ霸`是低电平有效的控制信号
>
> R/W霸是读写命令信号



## 题目

设CPU共有**16根地址线**，**8根数据线**，并用MREQ作访存控制信号，R/W作读/写命令信号。

现有这些存储芯片:

- ROM（2K×8位、4K×4位、8K×8位)

- RAM（1K×4位、2K×8位、4K×8位）
- 及74138译码器和其他门电路（门电路自定）。

试从上述规格中选用合适的芯片,画出CPU和存储芯片的连接图.要求如下:

(1)最小4k地址作为系统程序区，4096~16383地址范围为用户地址区。

(2)指出选用的存储芯片类型及数量。

(3)详细画出片选逻辑。

## 答案

### 第一问

> 系统程序区只能用`ROM`
>
> 用户地址区只能用`RAM`

`八根数据线`  的作用是计算CPU大小

8位x4k=系统程序区的大小

8位x（16383-4096）=（16K-4K）x8位=12Kx8位=用户地址区的大小

### 第二问

系统程序区的存储芯片选择：

从题目中给的ROM里面选，优先选择`位扩展`，所以我们选择**两片4Kx4位的ROM芯片**



用户地址区的存储芯片选择：

从题目中给的RAM里面选：需要**3片4Kx8位的**

### 第三问

之后我们画地址线的示意图，但是这里请注意，如果是位扩展的话，也就是我们上面的两片4Kx4位的ROM芯片，他们不会在这里显示出来，他们公用一段区间的地址线。你可以这样理解，原来可以塞满一半房间的东西，经过位扩展，我们就可以塞满整个房间了



之后就可以画出来**前两块**的地址线示意图了![image-20230613170505830](https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/image-20230613170505830.png)

> 为什么是从A0写到A15的解释：因为题目说了有16根地址线
>
> 为什么从A0写到A11都是1：因为4K是2的12次方，从A0到A11之间全部填1这个区间的大小就是4K



**后三块**的地址线示意图：![image-20230613171318684](https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/image-20230613171318684.png)





ok。下面开始画**片选逻辑** 

初始图片：![image-20230613171538132](../pic/image-20230613171538132.png)

之后我们连接CBA这三条线

![image-20230613172149743](../pic/image-20230613172149743.png)

之后进行连接![image-20230613172229466](../pic/image-20230613172229466.png)



之后连接我们自己的芯片，都连接到4K![image-20230613172411544](../pic/image-20230613172411544.png)



之后连数据线，注意之前我们提到的位扩展，这里就需要显示出来了![image-20230613172612348](../pic/image-20230613172612348.png)



之后连接RAM芯片，由于他们都是8位，所以全都连上![image-20230613172736038](../pic/image-20230613172736038.png)



这里需要知道

> G1是高电平，也就是1
>
> G2A和G2B是低电平，也就是0
>
> `MREQ霸`是低电平有效的控制信号，也是0

所以我们连接两个低电平的线![image-20230613173154222](../pic/image-20230613173154222.png)





之后写解码器的输出位置![image-20230613173425336](../pic/image-20230613173425336.png)进行连接![image-20230613173540092](../pic/image-20230613173540092.png)



之后还有R/W接口没进行连接

> 这里需要注意的是ROM只能读，RAM既可以读又可以写

![image-20230613173846427](../pic/image-20230613173846427.png)

但是ROM也需要连接东西！！！！虽然连接的这个我也不知道是啥![image-20230613173956437](../pic/image-20230613173956437.png)







最后总览：![image-20230613174012018](../pic/image-20230613174012018.png)



# 设计主存地址与命中率

## 题目

设主存容量为256KB，Cache容量为2KB，每字块8个字，每个字8位。

(1) 直接映射的方式下设计主存地址

(2) 二路组相联方式下设计主存地址

(3) 全相联方式下设计主存地址

(4）若主存容量为256K×16位，块长不变，在四路组相联映射方式下设计主存地址

(5）设Cache初态为空，CPU依次从主存第0，1，2...，99号单元读出100个字(主存一次读出一个字)，并重复此次序读10次，问命中率是多少?有效命中的缓存为t，命中主存（未命中）为5t，系统的效率是多少？ 有缓存和没有缓存速度提高的倍数是多少

## 答案

> 8bit=1Byte=？个字（不固定）

### 第一问

比特构成字节构成字构成字块



先看`字块内地址`，每个字块8个字，一个字等于8bit也就是一个字节，所以说一个字块8Byte=2^3，所以字块内地址填3

再来看`Cache字块地址`，Cache的容量为2KB=2^11，之后计算里面有多少个字块，也就是`2^11/8=2^8`,所以Cache字块地址为8

最后来看`主存字块标记`,主存容量为256KB=`2^18`，所以主存字块标记=18-8-3=7

| 主存字块标记 | Cache字块地址 | 字块内地址 |
| ------------ | ------------- | ---------- |
| 7            | 8             | 3          |

### 第二问

还是先来看`字块内地址`，不变

`组地址`的计算方法：Cache字块数量/二路组相联中的2，也就是`2^8/2=2^7`，所以这里填7

`主存字块标记`计算方法：18-7-3=8

| 主存字块标记 | 组地址 | 字块内地址 |
| ------------ | ------ | ---------- |
| 8            | 7      | 3          |

### 第三问

`字块内地址`不变

`主存字块标记`=18-3=15

| 主存字块标记 | 字块内地址 |
| ------------ | ---------- |
| 15           | 3          |

### 第四问

由题知块长不变，所以字块内地址还是3

缓存也没变，所以组地址为2^8/4=6

只有主存容量改变了,换算一下256Kx16位=512Kx8位，所以是2^19x8位，主存字块标记=19-6-3=10

| 主存字块标记 | 组地址 | 字块内地址 |
| ------------ | ------ | ---------- |
| 10           | 6      | 3          |

### 第五问

每个字块有8个字，然后题目说有100个字，就算100/8≈12，然后初态为空 12+1=13

所以命中率h=100x10-13/100x10=0.987



下面计算系统的效率e

tc=t   tm=5t

平均访问时间ta=h*tc+(1-h)tm

e=tc/ta=t/(0.987xt+(1-0.987)x5t)=95%



下面计算提高的倍数 b

b=(tm/ta) -1

# 存储器的校验（海明码）

首先记住奇偶校验小组

![image-20230625202724260](../pic/image-20230625202724260.png)

## 第一题

### 题目

已知收到下面的汉明码，分别写出它们所对应的欲传送代码

1100000（按偶性配置）

0011001（按奇性配置）

### 答案

首先按照奇偶校验小组来进行计算

![image-20230625202854440](../pic/image-20230625202854440.png)

所以得到p4,p2,p1，注意这里要倒着写

![image-20230625202955517](../pic/image-20230625202955517.png)

修改它的第三位

所以我们可以得到需要传送的代码，是除去检测位的组合，就是1000





下面来看按奇性配置

![image-20230625203147454](../pic/image-20230625203147454.png)

![image-20230625203453128](../pic/image-20230625203453128.png)



## 第二题

### 题目

欲传送的二进制代码为1001101，用奇校验来确定其对应的海明码为

### 答案

这里有一个公式![image-20230625204550709](../pic/image-20230625204550709.png)

n的意思是需要传送的代码的个数，这里是七位

之后需要试出来k的值

这里试出来k的值为4，k的含义是检测位的个数，所以我们需要4位检测位，所以是c1,c2,c4,c8

![image-20230625205138252](../pic/image-20230625205138252.png)

# 数的表示及加减法运算

## 题目

![image-20230613202821656](../pic/image-20230613202821656.png)

## 答案

### 第一问

![image-20230613203610806](../pic/image-20230613203610806.png)

上面的溢出很正常，不是下面的溢出，只是单纯的数字溢出

不过需要进行验算溢出的操作

![image-20230613203812515](../pic/image-20230613203812515.png)

### 第二问

![image-20230613204209881](../pic/image-20230613204209881.png)

这个也需要判断是否溢出

![image-20230613204356579](../pic/image-20230613204356579.png)

# 定点数和浮点数表示

> IEEE标准：浮点数字长16位，其中阶码5位（含一位阶符），尾数11位（含1位数符）

## 题目

将十进制数字`-58`写成二进制`定点数`和`浮点数`

并分别写出它在`定点机`和`浮点机`中的机器数形式

## 答案

需要凑够**16位**

二进制定点数：-00 0011 1010  

二进制浮点数：-0.1110100000 x 2^110^







![image-20230613210033063](../pic/image-20230613210033063.png)

# 浮点数的加减运算

## 题目

![image-20230615185526578](../pic/image-20230615185526578.png)

## 答案

### 加法

首先要做的是要把xy这两个数换成基数形式 

这里注意的是要用两位阶符和数符来表示，也就是说正数为00，负数为11

![image-20230615190026294](../pic/image-20230615190026294.png)

然后计算他们俩的补码，符号位不变，数值位取反+1



之后就要计算了：

1. 对阶：![image-20230615190429302](../pic/image-20230615190429302.png)，之后我们要把阶码小的那个向阶码大的数字看齐，也就是把11,101转换成11,110,他们俩差1，说明需要把x补的数值位的小数点向左移动一位，![image-20230615190942569](../pic/image-20230615190942569.png)
2. 尾数求和：把x和y的尾数进行相加![image-20230615191155647](../pic/image-20230615191155647.png)
3. 规格化：这个up说，考试都是规格化的，所以直接写上已规格化就行了
4. 舍入（必须右规才有舍入）：这里没有
5. 溢出判断：看阶码，先计算阶码 ，之前已经计算过了：11,110;11.010000，（up主说：如果阶码是10或者01就是溢出了）所以这个没溢出，一般的话都是没溢出的！！无舍入，无溢出！

### 减法

 直接来到尾数求和这一步

因为之前的都一样，这里是把x-y改成x+（-y）就可以了![image-20230615192106080](../pic/image-20230615192106080.png)

之后进行左规：![image-20230615194428173](../pic/image-20230615194428173.png)并且这里左规了2位，需要把阶数-2就行了





总结：

左规：尾数左移，小数点右移，阶码减少

右规：相反



阶符：01发生了上溢，10发生了下溢

# 中断屏蔽及CPU执行程序轨迹

## 题目

![image-20230615195453326](../pic/image-20230615195453326.png)

## 答案

先来看道题：

![image-20230615195910756](../pic/image-20230615195910756.png)

并且可以根据3-1-4-2画出这张图！！！



这是我们做这题起步：

![image-20230615200505519](../pic/image-20230615200505519.png)

![image-20230615201310527](../pic/image-20230615201310527.png)

# 输入输出系统方式

## 题目1

首先进行单位换算

DMA方式是以字块来进行传输的，所以由支持的最大批量为400个字节 知DMA方式每次发送一个字块（里面有400个字节）

DMA方式是每次发送一个字块中断一次，然后中断方式是传输一个字节中断一次

![image-20230615201840816](../pic/image-20230615201840816.png)

需要注意的是，中断方式不需要管存取周期就可以了，但是DMA需要考虑存储周期

总结:

DMA方式=存取周期+中断时间

中断方式：每一个字符x一次中断所需要的时间

## 题目2

![image-20230615203014359](../pic/image-20230615203014359.png)

其中第二步很难理解，注意看题：要计算1秒里面DMA`辅助操作`的`时钟周期数`，之前我们计算过传送4KB数据需要0.002秒，并且这0.002秒里面包含了（1000+500）个DMA辅助操作时钟周期，那么就好计算1秒里面的时钟周期数量了



HZ的意思就是1秒里面有多少个时钟周期，所以我们直接用`辅助操作的时钟周期/CPU的总时钟周期`就得到了

# 3.1

![image-20230625132357807](../pic/image-20230625132357807.png)

# 3.2

![image-20230625132622706](../pic/image-20230625132622706.png)![image-20230625132658581](../pic/image-20230625132658581.png)

# 3.3

![image-20230625133719867](../pic/image-20230625133719867.png)

# 3.4

![image-20230625134024072](../pic/image-20230625134024072.png)

这个比特率的公式也是记住就行。。。

# 4.1

# 4.2

# 4.8

![image-20230625165620476](../pic/image-20230625165620476.png)

这道题需要注意的是

第一问和第二问问到了cache地址和主存地址分别有多少位，直接根据大小就能判断多少位

如果是画表格那个位数是根据字块来判断位数的，也就是第四问

# 4.9

![image-20230625171221574](../pic/image-20230625171221574.png)

![image-20230625171236829](../pic/image-20230625171236829.png)

# 4.10

![image-20230625171446423](../pic/image-20230625171446423.png)

# 4.11

![image-20230625173338595](../pic/image-20230625173338595.png)

![image-20230625174212621](../pic/image-20230625174212621.png)

# 4.12

![image-20230625174322992](../pic/image-20230625174322992.png)

![image-20230625184323041](../pic/image-20230625184323041.png)

0.5这个数记住就行

# 4.13

![image-20230625185013731](../pic/image-20230625185013731.png)



2^4=16,可以表示16台

2^8=256>203,可以表示磁道号

2^5=32>20，可以表示盘面号

2^4=16 ，可以表示扇段号

# 5.1

![image-20230625185607806](../pic/image-20230625185607806.png)

# 5.3

首先进行单位换算

DMA方式是以字块来进行传输的，所以由支持的最大批量为400个字节 知DMA方式每次发送一个字块（里面有400个字节）

DMA方式是每次发送一个字块中断一次，然后中断方式是传输一个字节中断一次

![image-20230615201840816](../pic/image-20230615201840816.png)

需要注意的是，中断方式不需要管存取周期就可以了，但是DMA需要考虑存储周期

总结:

DMA方式=存取周期+中断时间

中断方式：每一个字符x一次中断所需要的时间

# 5.4

![image-20230615203014359](../pic/image-20230615203014359.png)

其中第二步很难理解，注意看题：要计算1秒里面DMA`辅助操作`的`时钟周期数`，之前我们计算过传送4KB数据需要0.002秒，并且这0.002秒里面包含了（1000+500）个DMA辅助操作时钟周期，那么就好计算1秒里面的时钟周期数量了



HZ的意思就是1秒里面有多少个时钟周期，所以我们直接用`辅助操作的时钟周期/CPU的总时钟周期`就得到了



# 6.1

![image-20230625190652313](../pic/image-20230625190652313.png)

# 6.4

![image-20230625190852177](../pic/image-20230625190852177.png)

# 6.12

![image-20230625191404018](../pic/image-20230625191404018.png)

两操作数符号均为1，结果的符号为0，故溢出了

# 6.13

![image-20230625191617062](../pic/image-20230625191617062.png)

# 6.29

![image-20230625192041022](../pic/image-20230625192041022.png)

至于为什么向右移动一位，丢掉了1，是因为题目上给的数值位限制是4位，所以超出的需要丢掉

# 6.30

![image-20230625192738031](../pic/image-20230625192738031.png)

![image-20230625193100910](../pic/image-20230625193100910.png)

# 7.1

![image-20230625193212373](../pic/image-20230625193212373.png)

# 7.4

# 7.6

# 8.1

![image-20230625200806778](../pic/image-20230625200806778.png)

![image-20230625200856465](../pic/image-20230625200856465.png)

# 8.2

![image-20230625201343537](../pic/image-20230625201343537.png)
