---
title: 小兔鲜项目
date: 2023-06-18 17:42:25
tags:
---

# Vue3入门

## 认识Vue3

### 1. Vue3组合式API体验

> 通过 Counter 案例 体验Vue3新引入的组合式API
>
> 并且需要注意的是Vue3是向下兼容的，也就是说你可以在Vue3的项目中继续写Vue2的代码

```vue
<script>
export default {
  data(){
    return {
      count:0
    }
  },
  methods:{
    addCount(){
      this.count++
    }
  }
}
</script>
```

```vue
<script setup>
import { ref } from 'vue'
const count = ref(0)
const addCount = ()=> count.value++
</script>
```

特点：

1. 代码量变少
2. 分散式维护变成集中式维护

### 2. Vue3更多的优势

![image.png](../pic/1678178235504-912ad469-1a9a-469d-a8dc-411a55963329.png)


## 使用create-vue搭建Vue3项目

### 1. 认识create-vue

> create-vue是Vue官方新的脚手架工具，底层切换到了 vite （下一代前端工具链），为开发提供极速响应


![image.png](../pic/1678178479590-ac164009-4a72-4448-85bf-67dc13f3d0c4.png)

### 2. 使用create-vue创建项目

> 前置条件 - 已安装16.0或更高版本的Node.js，
>
> C:\Users\Xu>node -v
> v16.16.0
>
> 可以看到这里我是16.16版本，希望不会出现依赖冲突

执行如下命令，这一指令将会安装并执行 create-vue

```bash
npm init vue@latest
```

![image.png](../pic/1678178685782-71a3b311-423d-4528-aae9-85e6068db452.png)

我去，这看着比vue2页面高级多了

![image-20230618181913327](../pic/image-20230618181913327.png)





## 熟悉项目和关键文件

![image.png](../pic/1678178749511-f4a42cbf-987b-46a7-9a01-9cd4f00a5fcf.png)

## 组合式API - setup选项

### 1. setup选项的写法和执行时机

写法

```vue
<script>
  export default {
    setup(){
      
    },
    beforeCreate(){
      
    }
  }
</script>
```

执行时机

> 在beforeCreate钩子之前执行

![image.png](../pic/1678179048672-603fdc19-4a41-4542-af55-702776625358.png)

### 2. setup中写代码的特点

> 在setup函数中写的数据和方法需要在末尾以对象的方式return，才能给模版使用

```vue
<script>
  export default {
    setup(){
      const message = 'this is message'
      const logMessage = ()=>{
        console.log(message)
      }
      // 必须return才可以
      return {
        message,
        logMessage
      }
    }
  }
</script>
```

### 3. `<script setup>`语法糖

> script标签添加 setup标记，不需要再写导出语句，默认会添加导出语句

![image-20230618193611568](../pic/image-20230618193611568.png)

```vue
<script setup>
  const message = 'this is message'
  const logMessage = ()=>{
    console.log(message)
  }
</script>
```

需要注意的是。setup中的this已经不指向组件实例啦，指向的undefined。

## 组合式API - reactive和ref函数

### 1. reactive

> 接受**对象类型数据**的参数传入并返回一个响应式的对象


```vue
<script setup>
 // 导入
 import { reactive } from 'vue'
 // 执行函数 传入参数 变量接收
 const state = reactive({
   msg:'this is msg'
 })
 const setSate = ()=>{
   // 修改数据更新视图
   state.msg = 'this is new msg'
 }
</script>

<template>
  {{ state.msg }}
  <button @click="setState">change msg</button>
</template>
```

### 2. ref

> 接收**简单类型**或者**对象类型**的数据传入并返回一个响应式的对象

```vue
<script setup>
 // 导入
 import { ref } from 'vue'
 // 执行函数 传入参数 变量接收
 const count = ref(0)
 const setCount = ()=>{
   // 修改数据更新视图必须加上.value
   count.value++
 }
</script>

<template>
  <button @click="setCount">{{count}}</button>
</template>
```

### 3. reactive 对比 ref

1. 都是用来生成响应式数据
2. 不同点
   1. reactive不能处理简单类型的数据
   2. ref参数类型支持更好，但是必须通过.value做访问修改
   3. ref函数内部的实现依赖于reactive函数
3. 在实际工作中的推荐
   1. 推荐使用ref函数，减少记忆负担，小兔鲜项目都使用**ref**

## 组合式API - computed

> 计算属性基本思想和Vue2保持一致，组合式API下的计算属性只是修改了API写法

下面这个计算属性会检测原始数据的变化，如果原始数据改变了，那么计算属性也会被调用！

![image-20230618195919871](../pic/image-20230618195919871.png)



## 组合式API - watch

> 侦听一个或者多个数据的变化，数据变化时执行回调函数，两个额外参数
>
> -  immediate控制立刻执行
> - deep开启深度侦听

### 1. 侦听单个数据

```vue
<script setup>
  // 1. 导入watch
  import { ref, watch } from 'vue'
  const count = ref(0)
  // 2. 调用watch 侦听变化
  watch(count, (newValue, oldValue)=>{//一个是变化之前的老值，一个是变化之后的新值
    console.log(`count发生了变化，老值为${oldValue},新值为${newValue}`)
  })
</script>
```

### 2. 侦听多个数据

> 侦听多个数据，第一个参数可以改写成数组的写法
>
> 这两个数据任何一个变化都会引起函数的触发！

```vue
<script setup>
  // 1. 导入watch
  import { ref, watch } from 'vue'
  const count = ref(0)
  const name = ref('cp')
  // 2. 调用watch 侦听变化
  watch([count, name], ([newCount, newName],[oldCount,oldName])=>{
    console.log(`count或者name变化了，[newCount, newName],[oldCount,oldName])
  })
</script>
```

### 3. immediate

> 在侦听器创建时立即触发回调（第一次就执行），响应式数据变化之后继续执行回调


```vue
<script setup>
  // 1. 导入watch
  import { ref, watch } from 'vue'
  const count = ref(0)
  // 2. 调用watch 侦听变化
  watch(count, (newValue, oldValue)=>{
    console.log(`count发生了变化，老值为${oldValue},新值为${newValue}`)
  },{
    immediate: true
  })
</script>
```

### 4. deep

> 通过watch监听的ref对象默认是浅层侦听的，直接修改嵌套的对象属性不会触发回调执行，需要开启deep
>
> 需要注意的是deep有性能损耗，尽量不要使用deep

```vue
<script setup>
  // 1. 导入watch
  import { ref, watch } from 'vue'
  const state = ref({ count: 0 })
  // 2. 监听对象state
  watch(state, ()=>{
    console.log('数据变化了')
  })
  const changeStateByCount = ()=>{
    // 直接修改不会引发回调执行
    state.value.count++
  }
</script>
```

添加deep属性就可以触发了

```vue
<script setup>
  // 1. 导入watch
  import { ref, watch } from 'vue'
  const state = ref({ count: 0 })
  // 2. 监听对象state 并开启deep
  watch(state, ()=>{
    console.log('数据变化了')
  },{deep:true})
  const changeStateByCount = ()=>{
    // 此时修改可以触发回调
    state.value.count++
  }
</script>
```

### 5.精确侦听对象的某个属性

需求：在不开启deep的前提下，侦听age的变化，只有age变化时才执行回调

![image-20230618212450674](../pic/image-20230618212450674.png)

## 组合式API - 生命周期函数

### 1. 选项式对比组合式

![image.png](../pic/1678183720098-4d40e806-bc0d-4c38-bcbe-9aed440f6b23.png)

### 2. 生命周期函数基本使用

> 1. 导入生命周期函数
> 2. 执行生命周期函数，传入回调

```vue
<scirpt setup>
import { onMounted } from 'vue'
onMounted(()=>{
  // 自定义逻辑
})
</script>
```

### 3. 执行多次

> 生命周期函数执行多次的时候，会按照顺序依次执行

```vue
<scirpt setup>
import { onMounted } from 'vue'
onMounted(()=>{
  // 自定义逻辑
})

onMounted(()=>{
  // 自定义逻辑
})
</script>
```

## 组合式API - 父子通信

### 1. 父传子

这里注意setup语法糖自动为我们注册了组件，所以我们不用在写components进行注册啦

> 基本思想
>
> 1. 父组件中给子组件绑定属性
> 2. 子组件内部通过props选项接收数据


![image.png](https://cdn.nlark.com/yuque/0/2023/png/274425/1678184258336-94b25c26-3150-456b-8981-64017ce7b021.png#averageHue=%2323282f&clientId=ud0819acc-4d21-4&from=paste&height=337&id=u6f845ad3&name=image.png&originHeight=674&originWidth=2402&originalType=binary&ratio=2&rotation=0&showTitle=false&size=416739&status=done&style=none&taskId=ubb5c9d64-f3d7-4a1b-bc05-9bf2af1e24d&title=&width=1201)

### 2. 子传父

> 基本思想
>
> 1. 父组件中给子组件标签通过@绑定事件
> 2. 子组件内部通过 emit 方法触发事件


![image.png](https://cdn.nlark.com/yuque/0/2023/png/274425/1678184380538-99cfc459-3e2e-4d2e-9162-350ef5f97ec6.png#averageHue=%23242830&clientId=ud0819acc-4d21-4&from=paste&height=388&id=u4588c125&name=image.png&originHeight=776&originWidth=2284&originalType=binary&ratio=2&rotation=0&showTitle=false&size=573924&status=done&style=none&taskId=ue5c30a58-7910-4a5b-8325-7e572c6348e&title=&width=1142)

## 组合式API - 模版引用

> 概念：通过 ref标识 获取真实的 dom对象或者组件实例对象

### 1. 基本使用

> 实现步骤：
>
> 1. 调用ref函数生成一个ref对象
> 2. 通过ref标识绑定ref对象到标签

<img src="https://cdn.nlark.com/yuque/0/2023/png/274425/1678184653565-b85c6f60-1089-4ad6-bed7-bbf781863db9.png#averageHue=%2324282f&clientId=ud0819acc-4d21-4&from=paste&height=442&id=u45efd4ee&name=image.png&originHeight=884&originWidth=1092&originalType=binary&ratio=2&rotation=0&showTitle=false&size=287093&status=done&style=none&taskId=u8dba8092-8819-44b3-a2ef-769257a611a&title=&width=546" alt="image.png" style="zoom:50%;" />

之后这个dom就被绑定到h1Ref对象身上了，同理也可以得到组件实例对象

![image-20230618214430735](../pic/image-20230618214430735.png)

### 2. defineExpose

> 默认情况下在` <script setup>`语法糖下组件内部的属性和方法是不开放给**父组件**(也就是说这个defineExpose是写在子组件里面的)访问的，可以通过defineExpose编译宏指定哪些属性和方法容许访问

说明：下面的代码将子组件里面的testMessage属性暴露出来，使之可以被父组件访问到

![image.png](https://cdn.nlark.com/yuque/0/2023/png/274425/1678184774906-7486a911-d18c-42e8-9aa7-fe2caa35e104.png#averageHue=%23ecf2ee&clientId=ud0819acc-4d21-4&from=paste&height=292&id=u0d5c6487&name=image.png&originHeight=584&originWidth=2512&originalType=binary&ratio=2&rotation=0&showTitle=false&size=239701&status=done&style=none&taskId=ub87fd095-cc3e-4e44-92f6-7c9643f831a&title=&width=1256)

## 组合式API - provide和inject

### 1. 作用和场景

> 顶层组件向任意的底层组件传递数据和方法，实现跨层组件通信

![image.png](https://cdn.nlark.com/yuque/0/2023/png/274425/1678185158603-5ae6c0e5-7baa-4de9-8a54-d1864d6c45d3.png#averageHue=%23fdf6ef&clientId=ud0819acc-4d21-4&from=paste&height=596&id=ua50e576b&name=image.png&originHeight=1192&originWidth=2558&originalType=binary&ratio=2&rotation=0&showTitle=false&size=414782&status=done&style=none&taskId=u0792870d-aa73-4c03-8342-aaa56e5d8fb&title=&width=1279)

### 2. 跨层传递普通数据

> 实现步骤
>
> 1. 顶层组件通过 `provide` 函数提供数据
> 2. 底层组件通过 `inject` 函数提供数据


![image.png](https://cdn.nlark.com/yuque/0/2023/png/274425/1678185321144-61e96ddf-f56c-4d57-83bc-c3c6899f72b2.png#averageHue=%23e4efe5&clientId=ud0819acc-4d21-4&from=paste&height=435&id=u9eb7aecf&name=image.png&originHeight=870&originWidth=1736&originalType=binary&ratio=2&rotation=0&showTitle=false&size=242848&status=done&style=none&taskId=u3d40b793-c4bc-44e7-83d9-4df25e56a7d&title=&width=868)

![image-20230618215039567](../pic/image-20230618215039567.png)

### 3. 跨层传递响应式数据

> 在调用provide函数时，第二个参数设置为ref对象

![image.png](https://cdn.nlark.com/yuque/0/2023/png/274425/1678185454566-b866e7f4-fa23-4c44-a199-8ca19b7d438e.png#averageHue=%2381b27d&clientId=ud0819acc-4d21-4&from=paste&height=473&id=u4efc7283&name=image.png&originHeight=946&originWidth=1732&originalType=binary&ratio=2&rotation=0&showTitle=false&size=237788&status=done&style=none&taskId=uf829094c-f2f8-4ca1-a8ed-c20f9eb79e4&title=&width=866)

### 4. 跨层传递方法

> 顶层组件可以向底层组件传递方法，底层组件调用方法修改顶层组件的数据

![image.png](https://cdn.nlark.com/yuque/0/2023/png/274425/1678185556536-669d0753-2dda-41ae-a750-b0e32f837d42.png#averageHue=%2394b88e&clientId=ud0819acc-4d21-4&from=paste&height=391&id=u449ca48f&name=image.png&originHeight=782&originWidth=2556&originalType=binary&ratio=2&rotation=0&showTitle=false&size=242321&status=done&style=none&taskId=u80c0e832-0efd-4886-9a15-05ebfb4c772&title=&width=1278)



# Pinia入门

## 什么是pinia

Pinia 是 Vue 的专属状态管理库，可以实现跨组件或页面共享状态，是 vuex 状态管理工具的替代品，和 Vuex相比，具备以下优势

1. 提供更加简单的API （去掉了 mutation ）
2. 提供符合组合式API风格的API （和 Vue3 新语法统一）
3. 去掉了modules的概念，每一个store都是一个独立的模块
4. 搭配 TypeScript 一起使用提供可靠的类型推断

## 创建空Vue项目并安装Pinia

### 1. 创建空Vue项目

```bash
npm init vue@latest
```

### 2. 安装Pinia并注册

```bash
npm i pinia
```

```javascript
import { createPinia } from 'pinia'

const app = createApp(App)
// 以插件的形式注册
app.use(createPinia())
app.use(router)
app.mount('#app')
```

## 实现counter

> 核心步骤：
>
> 1. 定义store
> 2. 组件使用store

1- 定义store

@/stores/counter.js

```javascript
import { defineStore } from 'pinia'
import { ref } from 'vue'

//这里导出方法。这个方法最好以use开头....
export const useCounterStore = defineStore('counter', ()=>{
  // 数据 （state）
  const count = ref(0)

  // 修改数据的方法 （action,这里既支持同步又支持异步）
  const increment = ()=>{
    count.value++
  }

  // 以对象形式返回
  return {
    count,
    increment
  }
})

```

2- 组件使用store

```vue
<script setup>
  // 1. 导入use方法
  import { useCounterStore } from '@/stores/counter'
  // 2. 执行方法得到store， store里有数据和方法
  const counterStore = useCounterStore()
</script>

<template>
	<button @click="counterStore.increment">
    {{ counterStore.count }}
  </button>
</template>
```

## 实现getters

> getters直接使用计算属性即可实现

```javascript
// 数据（state）
const count = ref(0)
// getter (computed)
const doubleCount = computed(() => count.value * 2)
```

## 异步action

> 思想：action函数既支持同步也支持异步，和在组件中发送网络请求写法保持一致
> 步骤：
>
> 1. store中定义action
> 2. 组件中触发action

1- store中定义action

```javascript
const API_URL = 'http://geek.itheima.net/v1_0/channels'

export const useCounterStore = defineStore('counter', ()=>{
  // 数据
  const list = ref([])
  // 异步action
  const loadList = async ()=>{
    const res = await axios.get(API_URL)
    list.value = res.data.data.channels
  }
  
  return {
    list,
    loadList
  }
})
```

2- 组件中调用action

```vue
<script setup>
	import { useCounterStore } from '@/stores/counter'
  const counterStore = useCounterStore()
  // 调用异步action
  counterStore.loadList()
</script>

<template>
	<ul>
    <li v-for="item in counterStore.list" :key="item.id">{{ item.name }}</li>
  </ul>
</template>
```

## storeToRefs保持响应式解构

> 直接基于store进行解构赋值，响应式数据（state和getter）会丢失响应式特性。
>
> 但是我们还是想用解构赋值，那么我们就可以使用storeToRefs辅助保持响应式

```vue
<script setup>
  import { storeToRefs } from 'pinia'
  import { useCounterStore } from '@/stores/counter'
  const counterStore = useCounterStore()
  // 使用它storeToRefs包裹之后解构保持响应式，
  // 注意，这里只能解构赋值数据，不管是对象类型还是基本数据类型都可以，但是不能解构赋值方法
  const { count } = storeToRefs(counterStore)
  // 如果想要解构赋值方法，使用这种方法解构就好啦
  const { increment } = counterStore
  
</script>

<template>
	<button @click="increment">
    {{ count }}
  </button>
</template>
```

# 项目起步

## 创建项目并整理目录

```bash
npm init vue@latest
```

![image.png](https://cdn.nlark.com/yuque/0/2022/png/274425/1670247123883-f43f81f8-7600-4fd7-aa82-2751d9032a54.png#averageHue=%23212120&clientId=ufebee43b-b163-4&from=paste&height=494&id=u1b534575&name=image.png&originHeight=659&originWidth=1280&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3380277&status=done&style=none&taskId=ud39028ba-b1d4-47ed-adf7-79865628edd&title=&width=960)

### src目录调整

![image-20230618222530147](../pic/image-20230618222530147.png)

## jsconfig.json配置别名路径

> 配置别名路径可以在写代码时联想提示路径，也就是说，在编写代码的过程中，一旦输入@/，VSCode会立刻联想出src下的所有子目录和文件，统一文件路径访问不容易出错
>
> 不过我下载了插件，这个就不用配置了

![image-20230618222757293](../pic/image-20230618222757293.png)

那么如何进行配置呢？

1. 在项目的根目录下新增jsconfig.json文件
2. 添加json格式的配置项，如下：

```json
{
  "compilerOptions" : {
    "baseUrl" : "./",
    "paths" : {
      "@/*":["src/*"]
    }
  }
}
```

## elementPlus引入

### 1. 安装elementPlus和自动导入插件

```bash
npm install element-plus --save
npm install -D unplugin-vue-components unplugin-auto-import
```

### 2. 配置自动按需导入

```javascript
// vite.config.ts
import { defineConfig } from 'vite'
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

export default defineConfig({
  // ...
  plugins: [
    // ...
    AutoImport({
      resolvers: [ElementPlusResolver()],
    }),
    Components({
      resolvers: [ElementPlusResolver()],
    }),
  ],
})
```

### 3. 测试组件

```vue
<template>
  <el-button type="primary">i am button</el-button>
</template>
```

## 定制elementPlus主题

### 1. 安装sass

> 基于vite的项目默认不支持css预处理器，需要开发者单独安装

```bash
npm i sass -D
```

### 2. 准备定制化的样式文件

styles/element/index.scss

```javascript
/* 只需要重写你需要的即可 */
@forward 'element-plus/theme-chalk/src/common/var.scss' with (
  $colors: (
    'primary': (
      // 主色
      'base': #27ba9b,
    ),
    'success': (
      // 成功色
      'base': #1dc779,
    ),
    'warning': (
      // 警告色
      'base': #ffb302,
    ),
    'danger': (
      // 危险色
      'base': #e26237,
    ),
    'error': (
      // 错误色
      'base': #cf4444,
    ),
  )
)
```

### 3. 自动导入配置

> 这里自动导入需要深入到elementPlus的组件中，按照官方的配置文档来
>
> 1. 自动导入定制化样式文件进行样式覆盖
> 2. 按需定制主题配置 （需要安装 unplugin-element-plus）

vite.config.js

```javascript
import { fileURLToPath, URL } from "node:url";

import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";

import AutoImport from "unplugin-auto-import/vite";
import Components from "unplugin-vue-components/vite";
import { ElementPlusResolver } from "unplugin-vue-components/resolvers";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    vue(),
    AutoImport({
      resolvers: [ElementPlusResolver()],
    }),
    Components({
      resolvers: [ElementPlusResolver({ importStyle: "sass" })],
    }),
  ],
  resolve: {
    alias: {
      "@": fileURLToPath(new URL("./src", import.meta.url)),
    },
  },
  css: {
    preprocessorOptions: {
      scss: {
        // 自动导入定制化样式文件进行样式覆盖
        additionalData: `
          @use "@/styles/element/index.scss" as *;
        `,
      },
    },
  },
});

```

## axios安装并简单封装

### 1. 安装axios

```bash
npm i axios
```

### 2. 基础配置

> 官方文档地址：[https://axios-http.com/zh/docs/intro](https://axios-http.com/zh/docs/intro)
> 基础配置通常包括：
>
> 1. 实例化 - baseURL + timeout
> 2. 拦截器 - 携带token 401拦截等

![image-20230619091729590](../pic/image-20230619091729590.png)

utils/http.js

```javascript
import axios from 'axios'

// 创建axios实例
const httpInstance = axios.create({
  baseURL: 'http://pcapi-xiaotuxian-front-devtest.itheima.net',
  timeout: 5000
})

//目前这两个没啥用，以后再用
// axios请求拦截器
httpInstance.interceptors.request.use(config => {
  return config
}, e => Promise.reject(e))

// axios响应式拦截器
httpInstance.interceptors.response.use(res => res.data, e => {
  return Promise.reject(e)
})


export default httpInstance
```

### 3. 封装请求函数

apis/testAPI.js

```javascript
import httpInstance from '@/utils/http'

export function getCategoryAPI () {
  return httpInstance({
    url: 'home/category/head'
  })
}
```

### 4.进行测试

测试在哪进行都可以

```js
import { getCategoryAPI } from "@/apis/testAPI.js";

getCategoryAPI().then((res) => {
  console.log(res);
});
```



## 添加不在强制组件重命名的配置

这个是对eslint的配置

.eslintrc.cjs

```js
/* eslint-env node */
module.exports = {
  root: true,
  'extends': [
    'plugin:vue/vue3-essential',
    'eslint:recommended'
  ],
  parserOptions: {
    ecmaVersion: 'latest'
  },
  //添加不再强制要求组件重命名的配置
  rules:{
    'vue/multi-word-component-names':0,
  }
}

```

## 路由整体设计



路由设计原则：找页面的切换方式，如果是**整体切换**，则为一级路由，如果是在一级路由的内部进行的内容切换，则为二级路由

![image-20230619094847419](../pic/image-20230619094847419.png)



view/Login/index.vue

```html
<template>
  我是Login
</template>
```

views/Layout/index.vue

```html
<template>
  我是Layout
</template>
```





二级路由：如果是在一级路由的内部进行的内容切换，则为二级路由

views/Home/index.vue

```html
<template>
  我是home
</template>
```

views/Category/index.vue

```html
<template>
  我是Category
</template>
```





router/index.js

```javascript
// createRouter：创建router实例对象
// createWebHistory：创建history模式的路由

import { createRouter, createWebHistory } from "vue-router";
import Login from "@/views/Login/index.vue";
import Layout from "@/views/Layout/index.vue";
import Home from "@/views/Home/index.vue";
import Category from "@/views/Category/index.vue";

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  // path和component对应关系的位置
  routes: [
    {
      path: "/",
      component: Layout,
      children: [
        {
          path: "",
          component: Home,
        },
        {
          path: "category",
          component: Category,
        },
      ],
    },
    {
      path: "/login",
      component: Login,
    },
  ],
});

export default router;

```



添加一级路由出口

App.vue

```vue
<script setup></script>
<template>
  <!-- 添加一级路由出口 -->
  <router-view></router-view>
</template>

<style scoped></style>

```

添加二级路由出口

view/Layout/index.vue

```vue
<template>
  <div>我是layout</div>
  <!-- 添加二级路由出口 -->
  <router-view />
</template>

<script>
export default {};
</script>

<style></style>

```



## 静态资源引入和Error Lens安装

### 1. 静态资源引入

1. 图片资源 - 把 images 文件夹放到 assets 目录下
2. 样式资源 - 把 common.scss 文件放到 styles 目录下，然后在main.js中引入![image-20230619104426694](../pic/image-20230619104426694.png)

### 2. Error Lens插件安装

error lens是一个试试提供错误警告信息的VSCode插件，方便开发

![image-20230619104336861](../pic/image-20230619104336861.png)

![image.png](https://cdn.nlark.com/yuque/0/2023/png/274425/1677637778086-7314f9de-8130-4388-9fc3-0cf4c59b8454.png#averageHue=%232a2e36&clientId=u68bde7ec-09c8-4&from=paste&height=196&id=udc027a23&name=image.png&originHeight=392&originWidth=1528&originalType=binary&ratio=2&rotation=0&showTitle=false&size=87943&status=done&style=none&taskId=ue37b0611-a082-4595-9dde-66e51632ef7&title=&width=764)

## scss变量自动导入

为什么要自动导入？

在项目里一些组件共享的色值会以scss变量的方式统一放到一个名叫var.scss的文件中，正常组件中使用这些变量的时候，需要先导入var.scss文件。再使用内部的变量，比较繁琐，自动导入可以免去手动导入的步骤，直接使用内部的变量

![image-20230619104727521](../pic/image-20230619104727521.png)

styles/var.scss

```css
$xtxColor: #27ba9b;
$helpColor: #e26237;
$sucColor: #1dc779;
$warnColor: #ffb302;
$priceColor: #cf4444;
```

vite.config.js

```json
css: {
    preprocessorOptions: {
      scss: {
        // 自动导入scss文件
        additionalData: `
          @use "@/styles/element/index.scss" as *;
          @use "@/styles/var.scss" as *;
        `,
      }
    }
}
```

测试：

```vue
<template>
  <div class="test">我是layout</div>
  <!-- 添加二级路由出口 -->
  <router-view />
</template>

<script>
export default {};
</script>

<!-- 这里注意要加lang -->
<style scoped lang="scss">
.test {
  // 直接在这里使用就可以了
  color: $priceColor;
}
</style>
```

# Layout页

![image-20230619105759274](../pic/image-20230619105759274.png)

## 组件结构快速搭建

view/Latout/components/LayoutNav.vue

```vue
<script setup>

</script>

<template>
  <nav class="app-topnav">
    <div class="container">
      <ul>
        <template v-if="true">
          <li><a href="javascript:;"><i class="iconfont icon-user"></i>周杰伦</a></li>
          <li>
            <el-popconfirm title="确认退出吗?" confirm-button-text="确认" cancel-button-text="取消">
              <template #reference>
                <a href="javascript:;">退出登录</a>
              </template>
            </el-popconfirm>
          </li>
          <li><a href="javascript:;">我的订单</a></li>
          <li><a href="javascript:;">会员中心</a></li>
        </template>
        <template v-else>
          <li><a href="javascript:;">请先登录</a></li>
          <li><a href="javascript:;">帮助中心</a></li>
          <li><a href="javascript:;">关于我们</a></li>
        </template>
      </ul>
    </div>
  </nav>
</template>


<style scoped lang="scss">
.app-topnav {
  background: #333;
  ul {
    display: flex;
    height: 53px;
    justify-content: flex-end;
    align-items: center;
    li {
      a {
        padding: 0 15px;
        color: #cdcdcd;
        line-height: 1;
        display: inline-block;

        i {
          font-size: 14px;
          margin-right: 2px;
        }

        &:hover {
          color: $xtxColor;
        }
      }

      ~li {
        a {
          border-left: 2px solid #666;
        }
      }
    }
  }
}
</style>
```

view/Latout/components/LayoutHeader.vue

```vue
<script setup>

</script>

<template>
  <header class='app-header'>
    <div class="container">
      <h1 class="logo">
        <RouterLink to="/">小兔鲜</RouterLink>
      </h1>
      <ul class="app-header-nav">
        <li class="home">
          <RouterLink to="/">首页</RouterLink>
        </li>
        <li> <RouterLink to="/">居家</RouterLink> </li>
        <li> <RouterLink to="/">美食</RouterLink> </li>
        <li> <RouterLink to="/">服饰</RouterLink> </li>
      </ul>
      <div class="search">
        <i class="iconfont icon-search"></i>
        <input type="text" placeholder="搜一搜">
      </div>
      <!-- 头部购物车 -->
      
    </div>
  </header>
</template>


<style scoped lang='scss'>
.app-header {
  background: #fff;

  .container {
    display: flex;
    align-items: center;
  }

  .logo {
    width: 200px;

    a {
      display: block;
      height: 132px;
      width: 100%;
      text-indent: -9999px;
      background: url('@/assets/images/logo.png') no-repeat center 18px / contain;
    }
  }

  .app-header-nav {
    width: 820px;
    display: flex;
    padding-left: 40px;
    position: relative;
    z-index: 998;
  
    li {
      margin-right: 40px;
      width: 38px;
      text-align: center;
  
      a {
        font-size: 16px;
        line-height: 32px;
        height: 32px;
        display: inline-block;
  
        &:hover {
          color: $xtxColor;
          border-bottom: 1px solid $xtxColor;
        }
      }
  
      .active {
        color: $xtxColor;
        border-bottom: 1px solid $xtxColor;
      }
    }
  }

  .search {
    width: 170px;
    height: 32px;
    position: relative;
    border-bottom: 1px solid #e7e7e7;
    line-height: 32px;

    .icon-search {
      font-size: 18px;
      margin-left: 5px;
    }

    input {
      width: 140px;
      padding-left: 5px;
      color: #666;
    }
  }

  .cart {
    width: 50px;

    .curr {
      height: 32px;
      line-height: 32px;
      text-align: center;
      position: relative;
      display: block;

      .icon-cart {
        font-size: 22px;
      }

      em {
        font-style: normal;
        position: absolute;
        right: 0;
        top: 0;
        padding: 1px 6px;
        line-height: 1;
        background: $helpColor;
        color: #fff;
        font-size: 12px;
        border-radius: 10px;
        font-family: Arial;
      }
    }
  }
}
</style>
```

view/Latout/components/LayoutFooter.vue

```vue
<template>
  <footer class="app_footer">
    <!-- 联系我们 -->
    <div class="contact">
      <div class="container">
        <dl>
          <dt>客户服务</dt>
          <dd><i class="iconfont icon-kefu"></i> 在线客服</dd>
          <dd><i class="iconfont icon-question"></i> 问题反馈</dd>
        </dl>
        <dl>
          <dt>关注我们</dt>
          <dd><i class="iconfont icon-weixin"></i> 公众号</dd>
          <dd><i class="iconfont icon-weibo"></i> 微博</dd>
        </dl>
        <dl>
          <dt>下载APP</dt>
          <dd class="qrcode"><img src="@/assets/images/qrcode.jpg" /></dd>
          <dd class="download">
            <span>扫描二维码</span>
            <span>立马下载APP</span>
            <a href="javascript:;">下载页面</a>
          </dd>
        </dl>
        <dl>
          <dt>服务热线</dt>
          <dd class="hotline">400-0000-000 <small>周一至周日 8:00-18:00</small></dd>
        </dl>
      </div>
    </div>
    <!-- 其它 -->
    <div class="extra">
      <div class="container">
        <div class="slogan">
          <a href="javascript:;">
            <i class="iconfont icon-footer01"></i>
            <span>价格亲民</span>
          </a>
          <a href="javascript:;">
            <i class="iconfont icon-footer02"></i>
            <span>物流快捷</span>
          </a>
          <a href="javascript:;">
            <i class="iconfont icon-footer03"></i>
            <span>品质新鲜</span>
          </a>
        </div>
        <!-- 版权信息 -->
        <div class="copyright">
          <p>
            <a href="javascript:;">关于我们</a>
            <a href="javascript:;">帮助中心</a>
            <a href="javascript:;">售后服务</a>
            <a href="javascript:;">配送与验收</a>
            <a href="javascript:;">商务合作</a>
            <a href="javascript:;">搜索推荐</a>
            <a href="javascript:;">友情链接</a>
          </p>
          <p>CopyRight © 小兔鲜儿</p>
        </div>
      </div>
    </div>
  </footer>
</template>

<style scoped lang='scss'>
.app_footer {
  overflow: hidden;
  background-color: #f5f5f5;
  padding-top: 20px;

  .contact {
    background: #fff;

    .container {
      padding: 60px 0 40px 25px;
      display: flex;
    }

    dl {
      height: 190px;
      text-align: center;
      padding: 0 72px;
      border-right: 1px solid #f2f2f2;
      color: #999;

      &:first-child {
        padding-left: 0;
      }

      &:last-child {
        border-right: none;
        padding-right: 0;
      }
    }

    dt {
      line-height: 1;
      font-size: 18px;
    }

    dd {
      margin: 36px 12px 0 0;
      float: left;
      width: 92px;
      height: 92px;
      padding-top: 10px;
      border: 1px solid #ededed;

      .iconfont {
        font-size: 36px;
        display: block;
        color: #666;
      }

      &:hover {
        .iconfont {
          color: $xtxColor;
        }
      }

      &:last-child {
        margin-right: 0;
      }
    }

    .qrcode {
      width: 92px;
      height: 92px;
      padding: 7px;
      border: 1px solid #ededed;
    }

    .download {
      padding-top: 5px;
      font-size: 14px;
      width: auto;
      height: auto;
      border: none;

      span {
        display: block;
      }

      a {
        display: block;
        line-height: 1;
        padding: 10px 25px;
        margin-top: 5px;
        color: #fff;
        border-radius: 2px;
        background-color: $xtxColor;
      }
    }

    .hotline {
      padding-top: 20px;
      font-size: 22px;
      color: #666;
      width: auto;
      height: auto;
      border: none;

      small {
        display: block;
        font-size: 15px;
        color: #999;
      }
    }
  }

  .extra {
    background-color: #333;
  }

  .slogan {
    height: 178px;
    line-height: 58px;
    padding: 60px 100px;
    border-bottom: 1px solid #434343;
    display: flex;
    justify-content: space-between;

    a {
      height: 58px;
      line-height: 58px;
      color: #fff;
      font-size: 28px;

      i {
        font-size: 50px;
        vertical-align: middle;
        margin-right: 10px;
        font-weight: 100;
      }

      span {
        vertical-align: middle;
        text-shadow: 0 0 1px #333;
      }
    }
  }

  .copyright {
    height: 170px;
    padding-top: 40px;
    text-align: center;
    color: #999;
    font-size: 15px;

    p {
      line-height: 1;
      margin-bottom: 20px;
    }

    a {
      color: #999;
      line-height: 1;
      padding: 0 10px;
      border-right: 1px solid #999;

      &:last-child {
        border-right: none;
      }
    }
  }
}
</style>
```

view/Latout/index.vue

```vue
<script setup>
import LayoutNav from './components/LayoutNav.vue'
import LayoutHeader from './components/LayoutHeader.vue'
import LayoutFooter from './components/LayoutFooter.vue'
</script>

<template>
  <LayoutNav />
  <LayoutHeader />
  <RouterView />
  <LayoutFooter />
</template>
```

## 字体图标渲染

> 字体图标采用的是阿里的字体图标库，样式文件已经准备好，在 `index.html`文件中引入即可
>
> ![image-20230619110946417](../pic/image-20230619110946417.png)



![image-20230619111332619](https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/image-20230619111332619.png)

```html
  <link rel="stylesheet" href="//at.alicdn.com/t/font_2143783_iq6z4ey5vu.css">
```





效果：

![image-20230619111415232](https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/image-20230619111415232.png)

## 一级导航渲染

要把上面的导航信息根据后端传过来的数据进行渲染

![image.png](https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1677638045286-b328a3ce-8241-4ce7-9db3-e9c872da5b73.png)
**实现步骤**

1. 封装接口函数
2. 调用接口函数
3. v-for渲染模版

**代码落地**

apis/layout.js

```javascript
import httpInstance from '@/utils/http'

export function getCategoryAPI () {
  return httpInstance({
    url: '/home/category/head'
  })
}
```

views/components/LayoutHeader.vue

```vue
<script setup>
// 引入api
import { getCategoryAPI } from "@/apis/layout";
import { onMounted, ref } from "vue";

const categoryList = ref([]);
const getCategory = async () => {
  const res = await getCategoryAPI();
  // 赋值
  categoryList.value = res.result;
};

onMounted(() => getCategory());
</script>

<template>
  <header class="app-header">
    <div class="container">
      <h1 class="logo">
        <RouterLink to="/">小兔鲜</RouterLink>
      </h1>
      <ul class="app-header-nav">
        <!-- 遍历list中的数据，渲染列表 -->
        <li class="home" v-for="item in categoryList" :key="item.id">
          <RouterLink to="/">{{ item.name }}</RouterLink>
        </li>
      </ul>
      <div class="search">
        <i class="iconfont icon-search"></i>
        <input type="text" placeholder="搜一搜" />
      </div>
      <!-- 头部购物车 -->
    </div>
  </header>
</template>
```

## 吸顶导航交互实现

需求：浏览器在上下滚动的过程中，如果距离顶部的滚动距离大于78px，吸顶导航就显示，如果小于78px就隐藏 

### 1. 准备组件静态结构

view/Layout/components/LayoutFixed.vue

```vue
<script setup>

</script>

<template>
  <div class="app-header-sticky show">
    <div class="container">
      <RouterLink class="logo" to="/" />
      <!-- 导航区域 -->
      <ul class="app-header-nav ">
        <li class="home">
          <RouterLink to="/">首页</RouterLink>
        </li>
        <li>
          <RouterLink to="/">居家</RouterLink>
        </li>
        <li>
          <RouterLink to="/">美食</RouterLink>
        </li>
        <li>
          <RouterLink to="/">服饰</RouterLink>
        </li>
        <li>
          <RouterLink to="/">母婴</RouterLink>
        </li>
        <li>
          <RouterLink to="/">个护</RouterLink>
        </li>
        <li>
          <RouterLink to="/">严选</RouterLink>
        </li>
        <li>
          <RouterLink to="/">数码</RouterLink>
        </li>
        <li>
          <RouterLink to="/">运动</RouterLink>
        </li>
        <li>
          <RouterLink to="/">杂项</RouterLink>
        </li>
      </ul>

      <div class="right">
        <RouterLink to="/">品牌</RouterLink>
        <RouterLink to="/">专题</RouterLink>
      </div>
    </div>
  </div>
</template>


<style scoped lang='scss'>
.app-header-sticky {
  width: 100%;
  height: 80px;
  position: fixed;
  left: 0;
  top: 0;
  z-index: 999;
  background-color: #fff;
  border-bottom: 1px solid #e4e4e4;
  // 此处为关键样式!!!
  // 状态一：往上平移自身高度 + 完全透明
  transform: translateY(-100%);
  opacity: 0;

  // 状态二：移除平移 + 完全不透明
  &.show {
    transition: all 0.3s linear;
    transform: none;
    opacity: 1;
  }

  .container {
    display: flex;
    align-items: center;
  }

  .logo {
    width: 200px;
    height: 80px;
    background: url("@/assets/images/logo.png") no-repeat right 2px;
    background-size: 160px auto;
  }

  .right {
    width: 220px;
    display: flex;
    text-align: center;
    padding-left: 40px;
    border-left: 2px solid $xtxColor;

    a {
      width: 38px;
      margin-right: 40px;
      font-size: 16px;
      line-height: 1;

      &:hover {
        color: $xtxColor;
      }
    }
  }
}

.app-header-nav {
  width: 820px;
  display: flex;
  padding-left: 40px;
  position: relative;
  z-index: 998;

  li {
    margin-right: 40px;
    width: 38px;
    text-align: center;

    a {
      font-size: 16px;
      line-height: 32px;
      height: 32px;
      display: inline-block;

      &:hover {
        color: $xtxColor;
        border-bottom: 1px solid $xtxColor;
      }
    }

    .active {
      color: $xtxColor;
      border-bottom: 1px solid $xtxColor;
    }
  }
}
</style>
```



然后引入到

### 2. 获取滚动距离

安装vueuse

`npm i @vueuse/core`

用vueuse的函数来实现获取滚动的距离

### 3. 以滚动距离做判断条件控制组件盒子显示隐藏

> 核心逻辑：根据滚动距离判断当前show类名是否显示，大于78显示，小于78，不显示

view/Layout/components/LayoutFixed.vue

```vue
<script setup>
// vueUse
import { useScroll } from '@vueuse/core'
const { y } = useScroll(window)
</script>

<template>
  <!-- 以滚动距离做判断条件控制组件盒子显示隐藏 -->
  <div class="app-header-sticky" :class="{ show: y > 78 }">
    <!-- 省略部分代码 -->
  </div>
</template>
```

## Pinia优化重复请求

![image-20230619133325167](../pic/image-20230619133325167.png)

store/category.js

```javascript
import { ref } from 'vue'
import { defineStore } from 'pinia'
import { getCategoryAPI } from '@/apis/layout'
export const useCategoryStore = defineStore('category', () => {
  // 导航列表的数据管理
  // state 导航列表数据
  const categoryList = ref([])

  // action 获取导航数据的方法
  const getCategory = async () => {
    const res = await getCategoryAPI()
    categoryList.value = res.result
  }

  return {
    categoryList,
    getCategory
  }
})
```

在index页面中调用action初始化数据

![image-20230619135715610](../pic/image-20230619135715610.png)

然后就是在两个组件中使用了

![image-20230619135752483](../pic/image-20230619135752483.png)

另一个组件同理
