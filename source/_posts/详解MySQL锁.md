---
title: 详解MySQL锁
date: 2023-08-04 15:03:23
tags: MySQL
---

# 详解MySQL锁

锁是计算机协调多个进程或线程**并发访问**某一个资源的机制。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

 MySQL中的锁，按照锁的粒度分，分为以下三类： 

- 全局锁：锁定数据库中的所有表。 
- 表级锁：每次操作锁住整张表。 
- 行级锁：每次操作锁住对应的行数据。  

## 全局锁

全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML语句（insert、delete、update），DDL语句（CREATE、ALTER、DROP和TRUNCATE），前面两种语句的所有更新操作的提交语句都将被阻塞。 

其典型的使用场景是做**全库的逻辑备份**，对所有的表进行锁定，保证数据的完整性。

那为什么全库逻辑备份，就需要加全就锁呢？  



我们一起先来分析一下不加全局锁，可能存在的问题。 

假设在数据库中存在这样三张表: tb_stock 库存表，tb_order 订单表，tb_orderlog 订单日志表。

- 在进行数据备份时，先备份了tb_stock库存表。
- 然后接下来，在业务系统中，执行了下单操作，扣减库存，生成订单（更新tb_stock表，插入tb_order表）。
- 然后再执行备份 tb_order表的逻辑。
- 业务中执行插入订单日志操作。
- 最后，又备份了tb_orderlog表。

很容易发现，上面的备份行为是有问题的。出现了不一致的情况，比如说有新的订单，但是库存表中的库存没减少。



所以就需要全局锁来保持数据的一致性。



我们再来分析一下加了全局锁之后的情况：

- 对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、 DML全部都处于阻塞状态，但是可以执行**DQL语句（select）**，也就是处于**只读**状态，因为**数据备份就是查询操作**。 那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性 和完整性  



数据库中加全局锁，是一个比较重的操作，存在以下问题： 

- 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。 
- 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟  



所以在InnoDB引擎中，我们可以在备份时加上参数 `--single-transaction `参数来完成**不加锁**的一致性数据备份。  （但是这个我没深挖，等知道了会来填坑）

 `mysqldump --single-transaction -uroot –p123456 mydb > mydb.sql  `

## 表级锁

表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB等存储引擎中

对于表级锁，主要分为以下三类：

1. 表锁
2. 元数据锁（meta data lock，MDL）
3. 意向锁

### 表锁

表锁分为两类：

1. 表共享**读锁**（read lock）
2. 表独占**写锁**（write lock）

#### 读锁

![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691058663322-ed71947a-8987-4644-940b-8795d33889f3.png)

#### 写锁

![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691058830844-224c43cd-e4d5-4d08-8110-8936162eb0da.png)

###  元数据锁  

meta data lock , 元数据锁，简写MDL(这里的元数据，大家可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。)。

MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。

MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML、DDL冲突，保证读写的正确性。

在MySQL5.5中引入了MDL，当对一张表进行增删改查(insert\update\select\delete)的时候，加MDL读锁(共享)；当对表结构进行变更操作(alter)的时候，加MDL写锁(排他)。

常见的SQL操作时，所添加的元数据锁：

![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691062746884-33fe7cfe-95c3-46f4-9282-cc2250016ee6.png)

当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ /SHARED_WRITE），之间是兼容的。  

![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691062917288-049913ea-e8f3-453c-8e14-a54b1f5ad3f5.png)

 当执行SELECT语句时，添加的是元数据共享锁（SHARED_READ），会阻塞元数据排他锁 （EXCLUSIVE），之间是互斥的。

![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691063042564-06a2b66f-43a4-4b8f-bff0-1a8851fb4078.png) 

 我们可以通过下面的SQL，来查看数据库中的元数据锁的情况：   `select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks ;  `

![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691063080705-746ad6b8-ba32-493d-865f-0ea808a37ee8.png)

### 意向锁

为了避免DML（insert、delete、update）在执行时，加的**行锁**与**表锁**的冲突（如果线程一去更新这个表的语句，会自动给修改的那一行加上行锁。但是线程2去要给这个表加表锁之前首先需要遍历每一行看有没有行锁，效率就很低）。在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。

假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一下：



首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。

![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691063434550-5a21f83a-6112-47f7-8e8b-e2538fc94206.png)



 当客户端二，想对这张表加表锁时，会遍历整张表，检查当前表是否有对应的行锁。如果没有，则添加表锁。此时就会从第一行数据，检查到最后一行数据，效率较低。  

![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691063488707-a6a3f758-3903-4dfe-8164-9eb8503ce701.png)



但是意向锁就是为了解决这个效率低的问题的，下面就是加了意向锁之后的：

客户端一，在执行DML（insert、delete、update）操作时，会对涉及的**行**加行锁，同时也会对该**表**加上意向锁。  

![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691063561584-0c1e4851-354b-4d76-9847-f7eaf3833027.png)

而**其他客户端**，在对这张表加表锁的时候，会根据该**表上所加的意向锁**来判定**是否可以成功加表锁**，而不用逐行判断行锁情况了。  



并且意向锁也分为两种：

- 意向共享锁(IS): 由语句`select ... lock in share mode`添加 。 与表锁共享锁(read)兼容，与表锁排他锁(write)互斥。
- 意向排他锁(IX): 由`insert、update、delete、select...for update`添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。

 一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。 



 可以通过以下SQL，查看意向锁及行锁的加锁情况：  

```
 select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;  
```



##  行级锁  

行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。**应用在InnoDB存储引擎中**。

InnoDB的**数据是基于索引组织**的，**行锁是通过对索引上的索引项（id列+数据列）加锁来实现的**。对于行级锁，主要分为以下三类：

- 行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691063974968-586ff94f-82bb-4cb8-bc09-553a2c80e943.png)
- 间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691063980713-2fb85d7f-6cd1-48f1-bf52-8f5fb489a6f5.png)
- 临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691063986384-2dc28180-ef0a-48fd-a0ee-01589a4903f0.png)

### 行锁

InnoDB实现了以下两种类型的行锁：

- 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。
- 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。

两种行锁的兼容情况如下：

![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691064068295-f361a632-9d65-4686-b3b5-7dfffb221956.png)

 常见的SQL语句，在执行时，所加的行锁如下：  

![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691064083946-b8cf4a83-6708-4530-a714-607057aa5e20.png)

2). 演示

Next-Key Lock是**行锁和间隙锁**的组合，当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。 加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。

默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 **next-key 锁**进行搜索和索引扫描，以防止幻读。

- 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。
- InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据（就是where条件得是走索引的查询），那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。(也就是说如果不走索引查询，就会加表锁，如果走索引查询，就加行锁)



 可以通过以下SQL，查看意向锁及行锁的加锁情况：  

```
 select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;  
```



演示下：

 A. 普通的select语句，执行时，不会加锁。  

![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691064556424-77a2f6c7-641b-46f7-b137-071dd79841cb.png)

 B. select...lock in share mode，加共享锁，共享锁与共享锁之间兼容。  

![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691064640917-1ae5bc0e-aa27-42c9-affa-f4bc9dbca192.png)



但是共享锁与排他锁之间互斥。  

![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691064659275-b5773c22-d87c-4826-b50f-f46d601b7377.png)

 客户端一获取的是id为1这行的共享锁，客户端二是可以获取id为3这行的排它锁的，因为不是同一行数据。 而如果客户端二想获取id为1这行的排他锁，会处于阻塞状态，以为共享锁与排他锁之间互斥。  



 C. 排他锁与排他锁之间互斥  

![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691064703745-ac1c4845-9e11-4f1c-87e2-b554d2802ef8.png)

 当客户端一，执行update语句，会为id为1的记录加排他锁； 客户端二，如果也执行update语句更新id为1的数据，也要为id为1的数据加排他锁，但是客户端二会处于阻塞状态，因为排他锁之间是互斥的。 直到客户端一，把事务提交了，才会把这一行的行锁释放，此时客户端二，解除阻塞。  



 D. 无索引行锁升级为表锁  

![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691064735725-a539395a-9ca8-493f-99eb-6734186c72de.png)

在客户端一中，开启事务，并执行update语句，更新name为Lily的数据，也就是id为19的记录，但是由于name没建立索引，这时候update语句由行锁升级成了表锁 。 

然后在客户端二中更新id为3的记录，却不能直接执行，会处于阻塞状态。  



 接下来，我们再针对name字段建立索引，索引建立之后，再次做一个测试  

![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691064772116-53b1b583-bc19-4d7e-a902-3535dca10df7.png)

此时我们可以看到，客户端一，开启事务，然后依然是根据name进行更新。而客户端二，在更新id为3的数据时，更新成功，并未进入阻塞状态。 

这样就说明，我们根据索引字段进行更新操作，就可以避免行锁升级为表锁的情况。  

### 间隙锁和临键锁

默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。

- 索引上的等值查询(唯一索引)【比如update stu set age =10 where id =5】，给不存在的记录加锁时, 优化为间隙锁 。
- 索引上的等值查询(非唯一普通索引)【比如update stu set age =10 where name="xth"】，向右遍历时**最后一个值**不满足查询需求时，next-key lock 退化为间隙锁。
- 索引上的范围查询(唯一索引)--会访问到不满足条件的第一个值为止。

 注意：间隙锁唯一目的是**防止其他事务插入间隙**。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。  



举例：

 A. 索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁  

![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691065544559-602186ca-abd4-46b6-a6b8-40275d2ff044.png)



 B. 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。  

 介绍分析一下： 

我们知道InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值为18的数据，并加上共享锁，我们是只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个 结构中可能有多个18的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也就是29）。此时会**对18加临键锁**，并对**29之前的间隙加间隙锁**。  

![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691065565069-37af3997-9d03-40b7-b8b2-7e5be61488f3.png)![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691065571960-e2d0f28f-6ceb-45e0-a88d-704d1fde3676.png)

 

C. 索引上的**范围查询**(唯一索引)--会访问到不满足条件的第一个值为止  ![img](../pic/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/1691065587610-33c071aa-07d1-4131-ae74-5eac96706437.png)

查询的条件为id>=19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部分：

[19]

(19,25]

(25,+∞]

所以数据库数据在加锁时，将19加了行锁，25的临键锁（包含25及10-25的间隙），正无穷的临键锁(25-+∞的间隙)。
