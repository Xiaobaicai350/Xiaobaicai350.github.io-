---
title: 微信小程序
date: 2023-07-31 21:07:41
tags: 微信小程序
---

<a name="KPa43"></a>

# 小程序 - 起步

<a name="JOIWz"></a>

## 小程序简介

1. 小程序与普通网页开发的区别<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689554106959-1f4c2397-fb02-4609-a02f-b481b9251eb5.png#averageHue=%230d0404&clientId=ud24e9138-99cb-4&from=paste&height=465&id=uc8a3e3e1&originHeight=465&originWidth=1058&originalType=binary&ratio=1&rotation=0&showTitle=false&size=67318&status=done&style=none&taskId=uf4be5c50-277f-4508-8ece-018e868a1c0&title=&width=1058)
   <a name="RPo2v"></a>

## 小程序代码的构成

<a name="N1Vy8"></a>

### 项目结构

<a name="sffrV"></a>

#### 1. 了解项目的基本组成结构

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689554191705-a1a8afa4-6ed5-4da8-941e-b665ada3f9ff.png#averageHue=%23f4f6f6&clientId=ud24e9138-99cb-4&from=paste&height=638&id=u2e183943&originHeight=638&originWidth=376&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13650&status=done&style=none&taskId=u919f547e-a842-461d-a85e-73796a997f6&title=&width=376)

1.  pages 用来存放所有小程序的页面
2.  utils 用来存放工具性质的模块（例如：格式化时间的自定义模块）
3.  app.js 小程序项目的入口文件
4.  app.json 小程序项目的全局配置文件
5.  app.wxss 小程序项目的全局样式文件
6.  project.config.json 项目的配置文件
7.  sitemap.json 用来配置小程序及其页面是否允许被微信索引
    <a name="momR2"></a>

#### 2. 小程序页面的组成部分

小程序官方建议把所有小程序的页面，都存放在 pages 目录中，以单独的文件夹存在，如图所示：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689554259001-86356825-2cdd-4504-98af-5aac56f85f5e.png#averageHue=%23f2f5f5&clientId=ud24e9138-99cb-4&from=paste&height=554&id=u9f21b299&originHeight=554&originWidth=376&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25876&status=done&style=none&taskId=ua02f5802-2d26-427f-8135-8eb2d2fddb5&title=&width=376)<br />其中，每个页面由 4 个基本文件组成，它们分别是：

1.  .js 文件（页面的脚本文件，存放页面的数据、事件处理函数等）
2.  .json 文件（当前页面的配置文件，配置窗口的外观、表现等）
3.  .wxml 文件（页面的模板结构文件）
4.  .wxss 文件（当前页面的样式表文件）
    <a name="EKzLZ"></a>

### JSON 配置文件

<a name="BmEnk"></a>

#### 1. JSON 配置文件的作用

JSON 是一种数据格式，在实际开发中，JSON 总是以配置文件的形式出现。小程序项目中也不例外：通过不同的 .json 配置文件，可以对小程序项目进行不同级别的配置。<br />小程序项目中有 4 种 json 配置文件，分别是：

1. 项目根目录中的 app.json 配置文件
2. 项目根目录中的 project.config.json 配置文件
3. 项目根目录中的 sitemap.json 配置文件
4. 每个页面文件夹中的 .json 配置文件
   <a name="zjfH2"></a>

#### 2. app.json 文件

app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、窗口外观、界面表现、底部 tab 等。Demo 项目里边的 app.json 配置内容如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689554341640-8226b50a-1da5-44ec-9740-33a51063cc28.png#averageHue=%23fefdfc&clientId=ud24e9138-99cb-4&from=paste&height=532&id=u20c36ffd&originHeight=532&originWidth=605&originalType=binary&ratio=1&rotation=0&showTitle=false&size=59494&status=done&style=none&taskId=u065404df-dd65-4773-b95a-09870686fda&title=&width=605)<br />简单了解下这 4 个配置项的作用：

1. **pages**：用来记录当前小程序所有页面的路径
2. **window**：全局定义小程序所有页面的背景色、文字颜色等
3. **style**：全局定义小程序组件所使用的样式版本
4. sitemapLocation：用来指明 sitemap.json 的位置
   <a name="N7s9j"></a>

#### 3. project.config.json 文件

project.config.json 是项目配置文件，用来记录我们对小程序开发工具所做的个性化配置，例如：

-  setting 中保存了编译相关的配置
-  projectname 中保存的是项目名称
-  appid 中保存的是小程序的账号 ID
   <a name="OfmwY"></a>

#### 4. sitemap.json 文件

微信现已开放小程序内搜索，效果类似于 PC 网页的 SEO。sitemap.json 文件用来配置小程序页面是否允许微信索引。<br />当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索关键字和页面的索引匹配成功的时候，小程序的页面将可能展示在搜索结果中。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689554412578-0026cecc-aa28-4749-be3b-0df639c08b6b.png#averageHue=%23faf8f8&clientId=ud24e9138-99cb-4&from=paste&height=299&id=u10f9ea61&originHeight=299&originWidth=1473&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47761&status=done&style=none&taskId=udaf6b720-9c6d-4366-a1ea-e71843c22ad&title=&width=1473)<br />注意：sitemap 的索引提示是默认开启的，如需要关闭 sitemap 的索引提示，可在小程序项目配置文件 project.config.json 的 setting 中配置字段 checkSiteMap 为 false
<a name="IH5bx"></a>

#### 5. 页面的 .json 配置文件

小程序中的每一个页面，可以使用 .json 文件来对本页面的窗口外观进行配置，页面中的配置项会覆盖 app.json 的 window 中相同的配置项。例如：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689554431912-a70736f2-92a9-43e6-9e34-09e0dca19454.png#averageHue=%23fafaf9&clientId=ud24e9138-99cb-4&from=paste&height=799&id=ub63f31a0&originHeight=799&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&size=106436&status=done&style=none&taskId=ue5e64488-df3c-43fd-aa14-b419978c0e0&title=&width=1460)
<a name="Bvl11"></a>

#### 6. 新建小程序页面

只需要在 app.json -> pages 中新增页面的存放路径，小程序开发者工具即可帮我们自动创建对应的页面文件![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689554455971-63548721-46e4-459f-adf9-44fa9b568211.png#averageHue=%23f8f5f5&clientId=ud24e9138-99cb-4&from=paste&height=643&id=ue9aec2e6&originHeight=643&originWidth=988&originalType=binary&ratio=1&rotation=0&showTitle=false&size=95706&status=done&style=none&taskId=u40db1d37-4599-49a8-a1ad-140d7eaf75f&title=&width=988)
<a name="eZQBb"></a>

#### 7. 修改项目首页

只需要调整 app.json -> pages 数组中页面路径的前后顺序，即可修改项目的首页。小程序会把排在第一位的页面，当作项目首页进行渲染，如图所示：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689554479849-54b86eab-685f-4817-9b15-f519783cba88.png#averageHue=%23f9f7f6&clientId=ud24e9138-99cb-4&from=paste&height=801&id=u8657b308&originHeight=801&originWidth=1458&originalType=binary&ratio=1&rotation=0&showTitle=false&size=115205&status=done&style=none&taskId=u576c512f-ff3e-45bc-838f-1cc65223c20&title=&width=1458)
<a name="Una4Q"></a>

### WXML 模板

<a name="dzpRl"></a>

#### 1. 什么是 WXML

WXML（WeiXin Markup Language）是小程序框架设计的一套标签语言，用来构建小程序页面的结构，其作用类似于网页开发中的 HTML。
<a name="YO2DV"></a>

#### 2. WXML 和 HTML 的区别

- 标签名称不同
  - HTML （div, span, img, a）
  - WXML（view, text, image, navigator）
- 属性节点不同
  - <a href="#">超链接</a>
  - <navigator url="/pages/home/home"></navigator>
- 提供了类似于 Vue 中的模板语法
  - 数据绑定
  - 列表渲染
  - 条件渲染
    <a name="GdZjM"></a>

### WXSS 样式

<a name="xhFTv"></a>

#### 1. 什么是 WXSS

WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，类似于网页开发中的 CSS。
<a name="qWNjD"></a>

#### 2. WXSS 和 CSS 的区别

- 新增了 rpx 尺寸单位
  - CSS 中需要手动进行像素单位换算，例如 rem
  - WXSS 在底层支持新的尺寸单位 rpx，在不同大小的屏幕上小程序会自动进行换算
- 提供了全局的样式和局部样式
  - 项目根目录中的 app.wxss 会作用于所有小程序页面
  - 局部页面的 .wxss 样式仅对当前页面生效
- WXSS 仅支持部分 CSS 选择器
  - .class 和 #id
  - element
  - 并集选择器、后代选择器
  - ::after 和 ::before 等伪类选择器

<a name="ObqR4"></a>

### JS 逻辑交互

<a name="UKJ36"></a>

#### 1. 小程序中的 .js 文件

一个项目仅仅提供界面展示是不够的，在小程序中，我们通过 .js 文件来处理用户的操作。例如：响应用户的点击、获取用户的位置等等。
<a name="dXvAq"></a>

#### 2. 小程序中 .js 文件的分类

小程序中的 JS 文件分为三大类，分别是：

1. app.js
   1. 是整个小程序项目的入口文件，通过调用 App() 函数来启动整个小程序
2. 页面的 .js 文件
   1. 是页面的入口文件，通过调用 Page() 函数来创建并运行页面
3. 普通的 .js 文件
   1. 是普通的功能模块文件，用来封装公共的函数或属性供页面使用
      <a name="cTN6q"></a>

## 小程序的宿主环境

<a name="vOKOH"></a>

### 宿主环境简介

<a name="zB39u"></a>

#### 1. 什么是宿主环境

宿主环境（host environment）指的是程序运行所必须的依赖环境。例如：<br />Android 系统和 iOS 系统是两个不同的宿主环境。安卓版的微信 App 是不能在 iOS 环境下运行的，所以，Android 是安卓软件的宿主环境，脱离了宿主环境的软件是没有任何意义的！<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689554722220-b495faf4-81ea-4710-af2a-64f4e723971e.png#averageHue=%23c2fbc2&clientId=ud24e9138-99cb-4&from=paste&height=324&id=u661c2b64&originHeight=324&originWidth=1029&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22447&status=done&style=none&taskId=u4f89525c-9724-4af9-8e9d-d559e93bc73&title=&width=1029)
<a name="XUu9N"></a>

#### 2. 小程序的宿主环境

手机微信是小程序的宿主环境，如图所示：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689554741991-a2807ad9-7196-4584-953e-f5e7a99fc46a.png#averageHue=%23bffabf&clientId=ud24e9138-99cb-4&from=paste&height=326&id=uf104f7ac&originHeight=326&originWidth=1029&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29490&status=done&style=none&taskId=ubf5d7b3d-1c79-4479-9af8-aa693392319&title=&width=1029)<br />小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能，<br />例如：微信扫码、微信支付、微信登录、地理定位、etc…
<a name="ppQEC"></a>

### 通信模型

<a name="izzOD"></a>

#### 1. 通信的主体

小程序中通信的主体是渲染层和逻辑层，其中：

1. WXML 模板和 WXSS 样式工作在渲染层
2. JS 脚本工作在逻辑层

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689554789296-f465357a-3239-40f6-9736-420b0f99a9df.png#averageHue=%23f6f6f6&clientId=ud24e9138-99cb-4&from=paste&height=442&id=u4d692327&originHeight=442&originWidth=809&originalType=binary&ratio=1&rotation=0&showTitle=false&size=122210&status=done&style=none&taskId=ua67bb104-c368-413c-a484-101e4a930dc&title=&width=809)
<a name="dd5UE"></a>

#### 2. 小程序的通信模型

小程序中的通信模型分为两部分：

-  渲染层和逻辑层之间的通信
   - 由微信客户端进行转发
-  逻辑层和第三方服务器之间的通信
   - 由微信客户端进行转发

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689554817084-4ea40e2b-65b8-481b-8544-2198ffce0eb8.png#averageHue=%23f8f8f8&clientId=ud24e9138-99cb-4&from=paste&height=606&id=u48506bc2&originHeight=606&originWidth=811&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136363&status=done&style=none&taskId=u7ebee10d-9421-44a0-af7f-b5fbac48d6f&title=&width=811)
<a name="spWin"></a>

### 运行机制

<a name="DIAiG"></a>

#### 1.小程序启动的过程

1. 把小程序的代码包下载到本地
2. 解析 app.json 全局配置文件
3. 执行 app.js 小程序入口文件，调用 App() 创建小程序实例
4. 渲染小程序首页
5. 小程序启动完成
   <a name="I28GO"></a>

#### 2.页面渲染的过程

1. 加载解析页面的 .json 配置文件
2. 加载页面的 .wxml 模板和 .wxss 样式
3. 执行页面的 .js 文件，调用 Page() 创建页面实例
4. 页面渲染完成
   <a name="vRcCS"></a>

### 组件

<a name="VpjyV"></a>

#### 1. 小程序中组件的分类

小程序中的组件也是由宿主环境提供的，开发者可以基于组件快速搭建出漂亮的页面结构。官方把小程序的组件分为了 9 大类，分别是：

1. 视图容器
2. 基础内容
3. 表单组件
4. 导航组件
5. 媒体组件
6. map 地图组件
7. canvas 画布组件
8. 开放能力
9. 无障碍访问
   <a name="LFqMg"></a>

#### 2. 常用的视图容器类组件

- view
  - 普通视图区域
  - 类似于 HTML 中的 div，是一个块级元素
  - 常用来实现页面的布局效果
- scroll-view
  - 可滚动的视图区域
  - 常用来实现滚动列表效果
- swiper 和 swiper-item
  - 轮播图容器组件 和 轮播图 item 组件
    <a name="voAvD"></a>

#### 3. view 组件的基本使用

实现如图的 flex 横向布局效果：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689554962146-d9a91b07-5975-4046-8133-cbe17689f205.png#averageHue=%23fbf5f5&clientId=ud24e9138-99cb-4&from=paste&height=825&id=u5930e228&originHeight=825&originWidth=1496&originalType=binary&ratio=1&rotation=0&showTitle=false&size=126604&status=done&style=none&taskId=ue47a7473-a70b-46e4-9b7f-0b0936d33ba&title=&width=1496)
<a name="b72lG"></a>

#### 4. scroll-view 组件的基本使用

实现如图的纵向滚动效果：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689554977750-c4d64d2b-bb9c-498d-abd6-db960e2961ac.png#averageHue=%23fcfafa&clientId=ud24e9138-99cb-4&from=paste&height=900&id=u0008d0f5&originHeight=900&originWidth=1795&originalType=binary&ratio=1&rotation=0&showTitle=false&size=162915&status=done&style=none&taskId=ub66d1ae1-891f-49af-bcdd-d6b7db30c60&title=&width=1795)
<a name="c9xAW"></a>

#### 5. swiper 和 swiper-item 组件的基本使用

实现如图的轮播图效果：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689554991586-046bb223-0e63-41b3-a665-27e57285c889.png#averageHue=%23fdfbfb&clientId=ud24e9138-99cb-4&from=paste&height=788&id=u0d067bf5&originHeight=788&originWidth=1822&originalType=binary&ratio=1&rotation=0&showTitle=false&size=157889&status=done&style=none&taskId=udcc29032-98c7-4219-9ea8-de53167e05e&title=&width=1822)
<a name="n2nAb"></a>

#### 6. swiper 组件的常用属性

| **属性**               | **类型** | **默认值**        | **说明**             |
| ---------------------- | -------- | ----------------- | -------------------- |
| indicator-dots         | boolean  | false             | 是否显示面板指示点   |
| indicator-color        | color    | rgba(0, 0, 0, .3) | 指示点颜色           |
| indicator-active-color | color    | #000000           | 当前选中的指示点颜色 |
| autoplay               | boolean  | false             | 是否自动切换         |
| interval               | number   | 5000              | 自动切换时间间隔     |
| circular               | boolean  | false             | 是否采用衔接滑动     |

<a name="cmMtm"></a>

#### 7. 常用的基础内容组件

- text
  - 文本组件
  - 类似于 HTML 中的 span 标签，是一个行内元素
- rich-text
  - 富文本组件
  - 支持把 HTML 字符串渲染为 WXML 结构
    <a name="Alcpr"></a>

#### 8. text 组件的基本使用

通过 text 组件的 selectable 属性，实现长按选中文本内容的效果：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689555066423-bfc9bbfe-8703-4175-88b7-dc056a38df97.png#averageHue=%23fcfbfb&clientId=ud24e9138-99cb-4&from=paste&height=795&id=ua65a5a89&originHeight=795&originWidth=1232&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48957&status=done&style=none&taskId=u25237617-7200-4c86-918f-b8143c66b24&title=&width=1232)
<a name="XRL3u"></a>

#### 9. rich-text 组件的基本使用

通过 rich-text 组件的 nodes 属性节点，把 HTML 字符串渲染为对应的 UI 结构：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689555085444-79af2fda-8f17-44ca-b745-be0e85fce890.png#averageHue=%23fdfcfc&clientId=ud24e9138-99cb-4&from=paste&height=795&id=u553ef1bc&originHeight=795&originWidth=1392&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41779&status=done&style=none&taskId=u39596ac9-3528-4414-b8fe-76e9beb11e4&title=&width=1392)
<a name="T1A0l"></a>

#### 10. 其它常用组件

- button
  - 按钮组件
  - 功能比 HTML 中的 button 按钮丰富
  - 通过 open-type 属性可以调用微信提供的各种功能（客服、转发、获取用户授权、获取用户信息等）
- image
  - 图片组件
  - image 组件默认宽度约 300px、高度约 240px
- navigator
  - 页面导航组件
  - 类似于 HTML 中的 a 链接
    <a name="p2S6e"></a>

#### 11. button 按钮的基本使用

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689555122034-870b39a7-4135-4095-8b2d-6a9b69536371.png#averageHue=%23fbf8f8&clientId=ud24e9138-99cb-4&from=paste&height=799&id=ue6cbacbc&originHeight=799&originWidth=1486&originalType=binary&ratio=1&rotation=0&showTitle=false&size=189557&status=done&style=none&taskId=ufe46d9dd-6223-4de8-81c6-a2746a3aeff&title=&width=1486)
<a name="djPID"></a>

#### 12. image 组件的基本使用

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689555132841-d0e33555-595e-4016-a810-ba3f99e276cb.png#averageHue=%23fcfbfb&clientId=ud24e9138-99cb-4&from=paste&height=799&id=u173ee43b&originHeight=799&originWidth=1621&originalType=binary&ratio=1&rotation=0&showTitle=false&size=145068&status=done&style=none&taskId=u7f62fcb6-37fa-467c-9c4b-1d627e0dfac&title=&width=1621)
<a name="LvmfM"></a>

#### 13. image 组件的 mode 属性

image 组件的 mode 属性用来指定图片的裁剪和缩放模式，常用的 mode 属性值如下：

| **mode 值** | **说明**                                                     |
| ----------- | ------------------------------------------------------------ |
| scaleToFill | （默认值）缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素 |
| aspectFit   | 缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。 |
| aspectFill  | 缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。 |
| widthFix    | 缩放模式，宽度不变，高度自动变化，保持原图宽高比不变         |
| heightFix   | 缩放模式，高度不变，宽度自动变化，保持原图宽高比不变         |

<a name="o3QwJ"></a>

### API

<a name="GSo1g"></a>

#### 1. 小程序 API 概述

小程序中的 API 是由宿主环境提供的，通过这些丰富的小程序 API，开发者可以方便的调用微信提供的能力，例如：获取用户信息、本地存储、支付功能等。
<a name="UqnNt"></a>

#### 2. 小程序 API 的 3 大分类

小程序官方把 API 分为了如下 3 大类：

1. 事件监听 API
   1. 特点：以 on 开头，用来监听某些事件的触发
   2. 举例：wx.onWindowResize(function callback) 监听窗口尺寸变化的事件
2. 同步 API
   1. 特点1：以 Sync 结尾的 API 都是同步 API
   2. 特点2：同步 API 的执行结果，可以通过函数返回值直接获取，如果执行出错会抛出异常
   3. 举例：wx.setStorageSync('key', 'value') 向本地存储中写入内容
3. 异步 API
   1. 特点：类似于 jQuery 中的 $.ajax(options) 函数，需要通过 success、fail、complete 接收调用的结果
   2. 举例：wx.request() 发起网络数据请求，通过 success 回调函数接收数据
      <a name="zodNy"></a>

# 小程序 - 模板与配置

<a name="rVGma"></a>

## WXML 模板语法

<a name="EuMJn"></a>

### 数据绑定

<a name="E431t"></a>

#### 1. 数据绑定的基本原则

1. 在 data 中定义数据
2. 在 WXML 中使用数据
   <a name="pueSG"></a>

#### 2. 在 data 中定义页面的数据

在页面对应的 .js 文件中，把数据定义到 data 对象中即可：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563057230-1f691a3c-1899-4749-9400-1f65b35b2124.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=389&id=uba3f9c34&originHeight=389&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17499&status=done&style=none&taskId=u5cf758bc-a9e6-4008-b9fa-934c9ce06cf&title=&width=850)
<a name="WxRZV"></a>

#### 3. Mustache 语法的格式

把data中的数据绑定到页面中渲染，使用 Mustache 语法（双大括号）将变量包起来即可。语法格式为： <br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563077965-e9a104bf-0124-4f40-8096-dcc7fd7f007f.png#averageHue=%230c1122&clientId=ud24e9138-99cb-4&from=paste&height=130&id=uc20bba6a&originHeight=130&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7607&status=done&style=none&taskId=u6d792d0b-b773-4e2e-8f0f-40f947e0098&title=&width=850)
<a name="CsHHB"></a>

#### 4. Mustache 语法的应用场景

Mustache 语法的主要应用场景如下：

-   绑定内容
-   绑定属性
-   运算（三元运算、算术运算等）
    <a name="bNVBE"></a>

#### 5. 动态绑定内容

页面的数据如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563112492-fa5003fc-d8bc-48c0-b99d-f5f4e11d693e.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=277&id=ufebd4635&originHeight=277&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7610&status=done&style=none&taskId=uef1b68b5-7bb0-4579-b9df-4ad4dfea85d&title=&width=850)<br />页面的结构如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563146383-9f89de20-e6e9-4276-bd1c-5d06f6cc1f0d.png#averageHue=%230f1424&clientId=ud24e9138-99cb-4&from=paste&height=122&id=u8ae9b508&originHeight=122&originWidth=730&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10903&status=done&style=none&taskId=u3d249fa5-236a-4bb4-b945-b18ddd4a74f&title=&width=730)
<a name="ktSAx"></a>

#### 6. 动态绑定属性

这个语法很奇怪，vue里面是使用的v-bind，这里仍然使用的是插值，不过这样的好处是统一了<br />页面的数据如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563166867-62f7ba5e-7836-4258-89f4-2a424d612659.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=277&id=u737e6c9d&originHeight=277&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10410&status=done&style=none&taskId=u3ba368ab-2182-4be4-a2a4-213fe9313fd&title=&width=850)<br />页面的结构如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563175712-7eca17dd-5873-44e7-935d-d55c78d5ea05.png#averageHue=%230c1022&clientId=ud24e9138-99cb-4&from=paste&height=130&id=udda90019&originHeight=130&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5887&status=done&style=none&taskId=ua7b6d80e-894f-4368-a119-74d3652f3d6&title=&width=850)
<a name="MTWp4"></a>

#### 7. 三元运算

页面的数据如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563228456-5cb9381f-fe76-4dbd-b1fb-c753207430ca.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=277&id=ubd630020&originHeight=277&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11768&status=done&style=none&taskId=u0203e94a-71e8-479a-9b02-8f7841c053f&title=&width=850)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563233606-e3ff6a07-88c0-466c-9f4a-e76a2d0871f9.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=130&id=u8a53d3b2&originHeight=130&originWidth=859&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9467&status=done&style=none&taskId=u9ca09581-13ee-49e4-a589-67143c6385e&title=&width=859)
<a name="gU1Jk"></a>

#### 8. 算数运算

页面的数据如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563247874-709d7b5d-ebf3-4632-87e6-3ac61fde73eb.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=277&id=u242dd170&originHeight=277&originWidth=877&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13837&status=done&style=none&taskId=ue9036694-3809-45d8-9755-5736cb643e0&title=&width=877)<br />页面的结构如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563255646-ede5b496-54cb-42ba-99f6-2dac28161abd.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=130&id=uf631323a&originHeight=130&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8778&status=done&style=none&taskId=ua2edcacc-5f3c-4580-8796-dcc290fe716&title=&width=850)
<a name="LgEhf"></a>

### 事件绑定

<a name="tEOYM"></a>

#### 1. 什么是事件

事件是渲染层到逻辑层的通讯方式。通过事件可以将用户在**渲染层**产生的行为，**反馈到逻辑层**进行业务的处理。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563286611-35c67aa8-8cee-4737-aa3f-57e9cad4005b.png#averageHue=%23f9f9f9&clientId=ud24e9138-99cb-4&from=paste&height=832&id=ub5bd147c&originHeight=832&originWidth=1178&originalType=binary&ratio=1&rotation=0&showTitle=false&size=83899&status=done&style=none&taskId=u0d4a368a-5816-4445-9951-0600ce02174&title=&width=1178)
<a name="zVl35"></a>

#### 2. 小程序中常用的事件

| **类型** | **绑定方式**              | **事件描述**                                    |
| -------- | ------------------------- | ----------------------------------------------- |
| tap      | bindtap 或 bind:tap       | 手指触摸后马上离开，类似于 HTML 中的 click 事件 |
| input    | bindinput 或 bind:input   | 文本框的输入事件                                |
| change   | bindchange 或 bind:change | 状态改变时触发                                  |

<a name="rwowU"></a>

#### 3. 事件对象的属性列表

当事件回调触发的时候，会收到一个事件对象 event，它的详细属性如下表所示：

| **属性**       | **类型** | **说明**                                     |
| -------------- | -------- | -------------------------------------------- |
| type           | String   | 事件类型                                     |
| timeStamp      | Integer  | 页面打开到触发事件所经过的毫秒数             |
| target         | Object   | 触发事件的组件的一些属性值集合               |
| currentTarget  | Object   | 当前组件的一些属性值集合                     |
| detail         | Object   | 额外的信息                                   |
| touches        | Array    | 触摸事件，当前停留在屏幕中的触摸点信息的数组 |
| changedTouches | Array    | 触摸事件，当前变化的触摸点信息的数组         |

<a name="yjHQn"></a>

#### 4. target 和 currentTarget 的区别

target 是触发该事件的源头组件，而 currentTarget 则是当前事件所绑定的组件。举例如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563371907-353d956d-bb55-435a-a625-e619a8295459.png#averageHue=%23fcfbfb&clientId=ud24e9138-99cb-4&from=paste&height=309&id=u06cb3056&originHeight=309&originWidth=1057&originalType=binary&ratio=1&rotation=0&showTitle=false&size=34754&status=done&style=none&taskId=u88aee664-1c8f-4525-b583-865fa1958a4&title=&width=1057)<br />点击内部的按钮时，点击事件以冒泡的方式向外扩散，也会触发外层 view 的 tap 事件处理函数。<br />此时，对于外层的 view 来说：

- e.target 指向的是触发事件的源头组件，因此，e.target 是内部的按钮组件
- e.currentTarget 指向的是当前正在触发事件的那个组件，因此，e.currentTarget 是当前的 view 组件
  <a name="TIhBy"></a>

#### 5. bindtap 的语法格式

在小程序中，不存在 HTML 中的 onclick 鼠标点击事件，而是通过 tap 事件来响应用户的触摸行为。<br />通过 bindtap，可以为组件绑定 tap 触摸事件，语法如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563406884-ba3bca63-9f8f-4127-90f5-4f98ee8b3e89.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=130&id=u38ef24df&originHeight=130&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8069&status=done&style=none&taskId=u30443175-4663-4e8b-b472-55884cbc066&title=&width=850)<br />在页面的 .js 文件中定义对应的事件处理函数，事件参数通过形参 event（一般简写成 e） 来接收：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563415741-551c3a37-2640-485a-acef-f7ebe7104400.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=277&id=u720277a2&originHeight=277&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14856&status=done&style=none&taskId=u9729ac8d-b663-435f-896e-92c2b8d9a0d&title=&width=850)
<a name="y1t0n"></a>

#### 6. 在事件处理函数中为 data 中的数据赋值

通过调用 this.setData(dataObject) 方法，可以给页面 data 中的数据重新赋值，示例如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563433095-bfaf32d2-2489-4cc8-828f-5545ff5cfd8a.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=536&id=u691babe9&originHeight=536&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19931&status=done&style=none&taskId=uaae8a5d2-9b84-4b60-adc1-920043a4c59&title=&width=850)<br />**这里像react里面的setState**
<a name="ULvVk"></a>

#### 7. 事件传参

小程序中的事件传参比较特殊，不能在绑定事件的同时为事件处理函数传递参数。例如，下面的代码（vue写法）将不能正常工作：<br />![错误写法](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563463649-004df0de-6f08-4129-bc92-4c2f38392921.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=130&id=u71708925&originHeight=130&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=true&size=8734&status=done&style=none&taskId=u487277ee-80c7-4bb2-b8a1-c24d74c7391&title=%E9%94%99%E8%AF%AF%E5%86%99%E6%B3%95&width=850 "错误写法")<br />因为小程序会把 bindtap 的属性值，统一当作事件名称来处理，相当于要调用一个名称为 btnHandler(123) 的事件处理函数。

**正确写法：**<br />**传递参数**<br />可以为组件提供 data-* 自定义属性传参，其中 * 代表的是参数的名字，示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563494051-69cac883-c1b7-46bb-ada4-6ec317eb650c.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=130&id=uce91d720&originHeight=130&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7826&status=done&style=none&taskId=u715ff818-ec6b-4b65-8059-c3b4a00fd8e&title=&width=850)<br />最终：

-  info 会被解析为参数的名字
-  数值 2 会被解析为参数的值

**接收参数**<br />在事件处理函数中，通过 event.target.dataset.参数名 即可获取到具体参数的值，示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563528434-b3b67402-cd8c-4a12-b7dc-96d34fbaa83f.png#averageHue=%230c1022&clientId=ud24e9138-99cb-4&from=paste&height=315&id=u85664147&originHeight=315&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22761&status=done&style=none&taskId=udc96c887-a8b0-4ddb-907d-421431db432&title=&width=850)
<a name="eQzph"></a>

#### 8. bindinput 的语法格式

在小程序中，通过 input 事件来响应文本框的输入事件，语法格式如下：<br />通过 bindinput，可以为文本框绑定输入事件：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563565726-4b6089d0-3a1f-4348-989d-0a79dd371126.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=130&id=u6149e558&originHeight=130&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5373&status=done&style=none&taskId=u7a50e603-97c2-4f23-96f6-a5aa1306e00&title=&width=850)<br />在页面的 .js 文件中定义事件处理函数：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563573904-731b37f4-5469-49c3-b4c5-f027798c29f7.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=240&id=u752142cb&originHeight=240&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12363&status=done&style=none&taskId=u4d082c9f-143a-48fa-b922-012713ab6f1&title=&width=850)
<a name="QBSnC"></a>

#### 9. 实现文本框和 data 之间的数据同步

**因为小程序里面没有双向绑定，所以要自己手动绑定**<br />实现步骤：

1. 定义数据
2. 渲染结构
3. 绑定 input 事件处理函数

定义数据：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563610318-43c6d783-fbcb-4011-baa8-bf8aa3b0470c.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=277&id=u571a9b79&originHeight=277&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8069&status=done&style=none&taskId=u566d7dd7-4d1f-4626-b7bf-7c53818abaa&title=&width=850)<br />渲染结构：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563620167-3ee1187c-c60a-4ee0-9648-02da775e5fb9.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=130&id=ub6d063f9&originHeight=130&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6699&status=done&style=none&taskId=u30ce78ae-96bb-4cbd-8842-54100d40f38&title=&width=850)<br />绑定 input 事件处理函数：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563630714-586168ea-6243-4ba4-a0af-eb03cfedee12.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=351&id=u5bd723dd&originHeight=351&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18077&status=done&style=none&taskId=u3e06954c-c49c-4db5-bf20-e4bbdc6e65d&title=&width=850)
<a name="fstVe"></a>

### 条件渲染

<a name="WoWkc"></a>

#### 1. wx:if

在小程序中，使用 wx:if="{{condition}}" 来判断是否需要渲染该代码块：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563664008-ebcf035b-28d2-4e97-ac94-5dbfb1d6d442.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=130&id=uc76e2154&originHeight=130&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6411&status=done&style=none&taskId=u86e31b99-8c1a-42bd-b4cc-f6f8c6c7fc7&title=&width=850)<br />也可以用 wx:elif 和 wx:else 来添加 else 判断：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563672341-a7bf7dd7-7737-427b-b07b-74f8408732d5.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=204&id=u7ddf3601&originHeight=204&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14640&status=done&style=none&taskId=ua7f88ec5-25f2-41ef-bc30-817cec4e9cb&title=&width=850)
<a name="UltoT"></a>

#### 2. 结合 <block> 使用 wx:if

**很像vue的template**<br />如果要一次性控制多个组件的展示与隐藏，可以使用一个 <block></block> 标签将多个组件包装起来，并在<block> 标签上使用 wx:if 控制属性，示例如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563692691-1c3323c7-44be-459d-a67f-d2a7652dceaf.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=214&id=uce8d447e&originHeight=214&originWidth=756&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9678&status=done&style=none&taskId=u1f347edd-c475-4d34-a848-e9ed1a1fae8&title=&width=756)<br />注意： <block> 并不是一个组件，它只是一个包裹性质的容器，不会在页面中做任何渲染。
<a name="t7HKM"></a>

#### 3.hidden

在小程序中，直接使用 hidden="{{ condition }}" 也能控制元素的显示与隐藏：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563735275-3cff34ee-f4d3-48d0-8fbd-43c773fed11b.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=130&id=u743b838e&originHeight=130&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9201&status=done&style=none&taskId=u9e7a7427-6a0c-4535-8394-98faa5c082b&title=&width=850)
<a name="YfVJs"></a>

#### 4. wx:if 与 hidden 的对比

运行方式不同

-  wx:if 以动态创建和移除元素的方式，控制元素的展示与隐藏
-  hidden 以切换样式的方式（display: none/block;），控制元素的显示与隐藏

使用建议

-  频繁切换时，建议使用 hidden
-  控制条件复杂时，建议使用 wx:if 搭配 wx:elif、wx:else 进行展示与隐藏的切换
   <a name="MvB3j"></a>

### 列表渲染

<a name="HqmoZ"></a>

#### 1. wx:for

通过 wx:for 可以根据指定的数组，循环渲染重复的组件结构，语法示例如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563825415-bd8108f2-4063-462b-b023-d51f2a4ec2e7.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=204&id=u1a482ee0&originHeight=204&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10389&status=done&style=none&taskId=uf749727e-aeed-4600-b3fd-611d0b926b9&title=&width=850)<br />默认情况下，当前循环项的索引用 index 表示；当前循环项用 item 表示。
<a name="KBqeV"></a>

#### 2. 手动指定索引和当前项的变量名*

-  使用 wx:for-index 可以指定当前循环项的索引的变量名
-  使用 wx:for-item 可以指定当前项的变量名

示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563881533-fa2c8514-fe8f-4b00-aea9-b2f6c0edb879.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=204&id=u6309cbe8&originHeight=204&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13784&status=done&style=none&taskId=ud98c15a3-2f2d-4315-a3cf-8defc67c8d1&title=&width=850)
<a name="jCuL5"></a>

#### 3. wx:key 的使用

类似于 Vue 列表渲染中的 :key，小程序在实现列表渲染时，也建议为渲染出来的列表项指定唯一的 key 值，从而提高渲染的效率，示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563895983-96a48e62-efe6-46ac-b09d-b2ea7f9bcb5e.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=500&id=ub883a2fc&originHeight=500&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23839&status=done&style=none&taskId=u71453a2e-cb05-4743-928f-2821cba3bda&title=&width=850)
<a name="jutsv"></a>

## WXSS 模板样式

<a name="o6dC0"></a>

### 1. 什么是 WXSS

WXSS (WeiXin Style Sheets)是一套样式语言，用于美化 WXML 的组件样式，类似于网页开发中的 CSS。
<a name="RQfVn"></a>

### 2. WXSS 和 CSS 的关系

WXSS 具有 CSS 大部分特性，同时，WXSS 还对 CSS 进行了扩充以及修改，以适应微信小程序的开发。<br />与 CSS 相比，WXSS 扩展的特性有：

-  rpx 尺寸单位
-  @import 样式导入

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689563968445-fb640d7d-53fc-419f-ad89-4e65bdcb0b3e.png#averageHue=%23bdbcac&clientId=ud24e9138-99cb-4&from=paste&height=436&id=u395fbc3f&originHeight=436&originWidth=815&originalType=binary&ratio=1&rotation=0&showTitle=false&size=59762&status=done&style=none&taskId=u5dae1842-3407-4392-a854-6aafd807029&title=&width=815)
<a name="w1dIr"></a>

### rpx

<a name="B2R3N"></a>

#### 1. 什么是 rpx 尺寸单位

rpx（responsive pixel）是微信小程序独有的，用来解决屏适配的尺寸单位。
<a name="YdAYy"></a>

#### 2. rpx 的实现原理

rpx 的实现原理非常简单：鉴于不同设备屏幕的大小不同，为了实现屏幕的自动适配，rpx 把所有设备的屏幕，在宽度上等分为 750 份（即：当前屏幕的总宽度为 750rpx）。

- 在较小的设备上，1rpx 所代表的宽度较小
- 在较大的设备上，1rpx 所代表的宽度较大

小程序在不同设备上运行的时候，会自动把 rpx 的样式单位换算成对应的像素单位来渲染，从而实现屏幕适配。
<a name="OgYPR"></a>

#### 3. rpx 与 px 之间的单位换算*

在 iPhone6 上，屏幕宽度为375px，共有 750 个物理像素，等分为 750rpx。则：<br />750rpx = 375px = 750 物理像素<br />    1rpx = 0.5px  = 1物理像素

| **设备**     | **rpx换算px (屏幕宽度/750)** | **px换算rpx (750/屏幕宽度)** |
| ------------ | ---------------------------- | ---------------------------- |
| iPhone5      | 1rpx = 0.42px                | 1px = 2.34rpx                |
| iPhone6      | **1rpx = 0.5px**             | 1px = 2rpx                   |
| iPhone6 Plus | 1rpx = 0.552px               | 1px = 1.81rpx                |

官方建议：开发微信小程序时，设计师可以用 iPhone6 作为视觉稿的标准。<br />开发举例：在 iPhone6 上如果要绘制宽100px，高20px的盒子，换算成rpx单位，宽高分别为 200rpx 和 40rpx。
<a name="AtY4h"></a>

### 样式导入

<a name="cfk53"></a>

#### 1. 什么是样式导入

使用 WXSS 提供的 @import 语法，可以导入外联的样式表。
<a name="IpDrF"></a>

#### 2. @import 的语法格式

@import 后跟需要导入的外联样式表的相对路径，用 ; 表示语句结束。示例如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689564071555-e15a7ec7-dc35-437a-9201-23115c63d3ac.png#averageHue=%23f8f8f9&clientId=ud24e9138-99cb-4&from=paste&height=435&id=u1653ab3d&originHeight=435&originWidth=918&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16933&status=done&style=none&taskId=ue5cf5257-0d4e-42f1-8fc0-1955142b2b0&title=&width=918)
<a name="ckedk"></a>

### 全局样式和局部样式

<a name="Zs7Xg"></a>

#### 1. 全局样式

定义在 app.wxss 中的样式为全局样式，作用于每一个页面。
<a name="lA2Re"></a>

#### 2. 局部样式

在页面的 .wxss 文件中定义的样式为局部样式，只作用于当前页面。<br />注意：

1. 当局部样式和全局样式冲突时，根据就近原则，局部样式会覆盖全局样式
2. 当局部样式的权重大于或等于全局样式的权重时，才会覆盖全局的样式
   <a name="z2Um8"></a>

## 全局配置

<a name="biP8Y"></a>

### 全局配置文件及常用的配置项

小程序根目录下的 app.json 文件是小程序的全局配置文件。常用的配置项如下：

-  pages
   - 记录当前小程序所有页面的存放路径
-  window
   - 全局设置小程序窗口的外观
-  tabBar
   - 设置小程序底部的  tabBar 效果
-  style
   - 是否启用新版的组件样式
     <a name="hkKBq"></a>

### window

<a name="v2Nuc"></a>

#### 1. 小程序窗口的组成部分

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689564192200-50d4b8d9-46fb-4938-b9f3-f10bafb1e9bd.png#averageHue=%23fbfafa&clientId=ud24e9138-99cb-4&from=paste&height=778&id=u7115fe76&originHeight=778&originWidth=747&originalType=binary&ratio=1&rotation=0&showTitle=false&size=71966&status=done&style=none&taskId=u7f51e7b6-bb17-453c-8714-dc415968f79&title=&width=747)
<a name="i10CJ"></a>

#### 2. 了解 window 节点常用的配置项

| **属性名**                   | **类型** | **默认值** | **说明**                                                     |
| ---------------------------- | -------- | ---------- | ------------------------------------------------------------ |
| navigationBarTitleText       | String   | 字符串     | 导航栏标题文字内容                                           |
| navigationBarBackgroundColor | HexColor | #000000    | 导航栏背景颜色，如 #000000 只支持十六进制表示                |
| navigationBarTextStyle       | String   | white      | 导航栏标题颜色，仅支持 black / white                         |
| backgroundColor              | HexColor | #ffffff    | 窗口的背景色 只支持十六进制表示                              |
| backgroundTextStyle          | String   | dark       | 下拉 loading 的样式（那三个小圆点的颜色），仅支持 dark / light |
| enablePullDownRefresh        | Boolean  | false      | 是否全局开启下拉刷新                                         |
| onReachBottomDistance        | Number   | 50         | 页面上拉触底事件触发时距页面底部距离，单位为px               |

<a name="zsf3u"></a>

#### 3. 设置导航栏的标题

需求：把导航栏上的标题，从默认的 “WeChat”修改为“黑马程序员”，效果如图所示：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689564242893-998c5d6a-c1e2-4539-a60b-e89fb3109c15.png#averageHue=%23f9f6f6&clientId=ud24e9138-99cb-4&from=paste&height=433&id=LgvmW&originHeight=433&originWidth=425&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28134&status=done&style=none&taskId=uad66b43f-effa-4489-9a40-e15224d1377&title=&width=425)<br />设置步骤：app.json -> window -> navigationBarTitleText
<a name="mlHSn"></a>

#### 4. 设置导航栏的背景色

设置步骤：app.json -> window -> navigationBarBackgroundColor<br />需求：把导航栏标题的背景色，从默认的 #fff 修改为 #2b4b6b ，效果如图所示：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689564276978-079b2757-a2c1-4d2b-80ee-42917ca408bb.png#averageHue=%23c8af8e&clientId=ud24e9138-99cb-4&from=paste&height=295&id=u2f6797e1&originHeight=295&originWidth=429&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25451&status=done&style=none&taskId=uda43c660-9359-4f7e-87ef-4eed1ac8672&title=&width=429)
<a name="VYeAq"></a>

#### 5. 设置导航栏的标题颜色

设置步骤：app.json -> window -> navigationBarTextStyle<br />需求：把导航栏上的标题颜色，从默认的 black 修改为 white ，效果如图所示：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689564295512-9618baf7-f4db-479a-aab8-9ba669945d42.png#averageHue=%23cdcebc&clientId=ud24e9138-99cb-4&from=paste&height=295&id=ud24c2220&originHeight=295&originWidth=429&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25895&status=done&style=none&taskId=u02df0d81-0de4-498a-be4d-1e54a09aad9&title=&width=429)<br />注意： navigationBarTextStyle 的可选值只有 black 和 white
<a name="E0HQO"></a>

#### 6. 全局开启下拉刷新功能

**最好不要全局开启下拉刷新功能**<br />概念：下拉刷新是移动端的专有名词，指的是通过手指在屏幕上的下拉滑动操作，从而重新加载页面数据的行为。<br />设置步骤：app.json -> window -> 把 enablePullDownRefresh 的值设置为 true

注意：在 app.json 中启用下拉刷新功能，会作用于每个小程序页面！
<a name="MqjMB"></a>

#### 7. 设置下拉刷新时窗口的背景色

当全局开启下拉刷新功能之后，默认的窗口背景为白色。如果自定义下拉刷新窗口背景色，设置步骤为: app.json -> window -> 为 backgroundColor 指定16进制的颜色值 #efefef。效果如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689564415464-7d425144-31f5-401c-bfd9-dabdc74ab246.png#averageHue=%23f8f3f3&clientId=ud24e9138-99cb-4&from=paste&height=270&id=u87d4ec49&originHeight=270&originWidth=653&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29153&status=done&style=none&taskId=u5e18d31f-4d4d-45f6-b55a-354b82a9dd1&title=&width=653)
<a name="ahC92"></a>

#### 8. 设置下拉刷新时 loading 的样式

当全局开启下拉刷新功能之后，默认窗口的 loading 样式为白色，如果要更改 loading 样式的效果，设置步骤为 app.json -> window -> 为 backgroundTextStyle 指定 dark 值。效果如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689564431945-47f6975d-7656-4223-9641-4c8922bf011f.png#averageHue=%23f8f2f2&clientId=ud24e9138-99cb-4&from=paste&height=286&id=u8b67c8fb&originHeight=286&originWidth=662&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30738&status=done&style=none&taskId=u4fe8edc6-696c-4cdd-8e50-1f0b5b3f84a&title=&width=662)<br />注意： backgroundTextStyle 的可选值只有 light 和 dark
<a name="b2jxR"></a>

#### 9. 设置上拉触底的距离

概念：上拉触底是移动端的专有名词，通过手指在屏幕上的上拉滑动操作，从而加载更多数据的行为。<br />设置步骤： app.json -> window -> 为 onReachBottomDistance 设置新的数值

注意：默认距离为50px，如果没有特殊需求，建议使用默认值即可。
<a name="C5omx"></a>

### tabBar

<a name="mj0qo"></a>

#### 1. 什么是 tabBar

tabBar 是移动端应用常见的页面效果，用于实现多页面的快速切换。小程序中通常将其分为：<br />底部 tabBar<br />顶部 tabBar<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689564487814-b6011530-8d1b-42a9-85a9-bac5a4b50748.png#averageHue=%23f5f2f2&clientId=ud24e9138-99cb-4&from=paste&height=453&id=u2541b5d4&originHeight=453&originWidth=523&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17186&status=done&style=none&taskId=u7073bbd7-c8d8-4847-b5bc-cff3b6d51c5&title=&width=523)<br />注意：<br />tabBar中只能配置最少 2 个、最多 5 个 tab 页签<br />当渲染顶部 tabBar 时，不显示 icon，只显示文本
<a name="SeGqZ"></a>

#### 2. tabBar 的 6 个组成部分

1.  backgroundColor：tabBar 的背景色
2.  selectedIconPath：选中时的图片路径
3.  borderStyle：tabBar 上边框的颜色
4.  iconPath：未选中时的图片路径
5.  selectedColor：tab 上的文字选中时的颜色
6.  color：tab 上文字的默认（未选中）颜色

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689564513938-5b791703-6fd2-4154-8dc3-edb5bde87a6a.png#averageHue=%23faf1f1&clientId=ud24e9138-99cb-4&from=paste&height=335&id=u9d92e822&originHeight=335&originWidth=487&originalType=binary&ratio=1&rotation=0&showTitle=false&size=44034&status=done&style=none&taskId=u08b81585-5d1b-4a65-93a1-b9273bbbc88&title=&width=487)
<a name="mZ6XF"></a>

#### 3. tabBar 节点的配置项

| **属性**    | **类型** | **必填** | **默认值** | **描述**                                |
| ----------- | -------- | -------- | ---------- | --------------------------------------- |
| position    | String   | 否       | bottom     | tabBar 的位置，仅支持 bottom/top        |
| borderStyle | String   | 否       | black      | tabBar 上边框的颜色，仅支持 black/white |
|             | color    | HexColor | 否         |                                         |

 | tab 上文字的默认（未选中）颜色 |
| selectedColor | HexColor | 否 | 

 | tab 上的文字选中时的颜色 |
| backgroundColor | HexColor | 否 | 

 | tabBar 的背景色 |
| list | Array | 是 | 

 | tab 页签的列表，<br />最少 2 个、最多 5 个 tab |

<a name="TcP5G"></a>

#### 4. 每个 tab 项的配置选项

| **属性**         | **类型** | **必填** | **描述**                                              |
| ---------------- | -------- | -------- | ----------------------------------------------------- |
| pagePath         | String   | 是       | 页面路径，页面必须在 pages 中预先定义                 |
| text             | String   | 是       | tab 上显示的文字                                      |
| iconPath         | String   | 否       | 未选中时的图标路径；当 postion 为 top 时，不显示 icon |
| selectedIconPath | String   | 否       | 选中时的图标路径；当 postion 为 top 时，不显示 icon   |

<a name="otaPn"></a>

#### 案例：配置 tabBar

<a name="PoDYU"></a>

##### 步骤1 - 拷贝图标资源

把资料目录中的 images 文件夹，拷贝到小程序项目根目录中<br />将需要用到的小图标分为 3 组，每组两个，其中：

- 图片名称中包含 -active 的是选中之后的图标
- 图片名称中不包含 -active 的是默认图标

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689564628799-960700a1-79ea-4b54-8a0a-f3e62049d3cc.png#averageHue=%23f9f7f6&clientId=ud24e9138-99cb-4&from=paste&height=112&id=udbb52dac&originHeight=112&originWidth=631&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10835&status=done&style=none&taskId=u3c7362a8-2d6c-4cd1-bdf8-8982631a9af&title=&width=631)
<a name="Qll5G"></a>

##### 步骤2 - 新建 3 个对应的 tab 页面

通过 app.json 文件的 pages 节点，快速新建 3 个对应的 tab 页面，示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689564654343-faeb72cd-d21e-41e8-9631-de9a5d1ec64a.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=351&id=u2295665d&originHeight=351&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11796&status=done&style=none&taskId=u6f61cb97-ec11-49b5-8ab0-fa1a38dc983&title=&width=850)<br />其中，home 是首页，message 是消息页面，contact 是联系我们页面。
<a name="BYQdB"></a>

##### 步骤3 - 配置 tabBar 选项

1. 打开 app.json 配置文件，和 pages、window 平级，新增 tabBar 节点
2. tabBar 节点中，新增 list 数组，这个数组中存放的，是每个 tab 项的配置对象
3. 在 list 数组中，新增每一个 tab 项的配置对象。对象中包含的属性如下：
   1.  pagePath 指定当前 tab 对应的页面路径【必填】
   2.  text 指定当前 tab 上按钮的文字【必填】
   3.  iconPath 指定当前 tab 未选中时候的图片路径【可选】
   4.  selectedIconPath 指定当前 tab 被选中后高亮的图片路径【可选】

完整的配置代码<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689564708491-2176db48-7a77-451e-aa8e-29557dc2b716.png#averageHue=%230c1022&clientId=ud24e9138-99cb-4&from=paste&height=832&id=ue059ca3e&originHeight=832&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=51245&status=done&style=none&taskId=u6cde71de-9766-48ad-bc3b-e91f3e79924&title=&width=850)
<a name="bttqG"></a>

## 页面配置

<a name="An6p3"></a>

### 1. 页面配置文件的作用

小程序中，每个页面都有自己的 .json 配置文件，用来对当前页面的窗口外观、页面效果等进行配置。
<a name="pMvWq"></a>

### 2. 页面配置和全局配置的关系

小程序中，app.json 中的 window 节点，可以全局配置小程序中每个页面的窗口表现。<br />如果某些小程序页面想要拥有特殊的窗口表现，此时，“页面级别的 .json 配置文件”就可以实现这种需求。

注意：当页面配置与全局配置冲突时，根据就近原则，最终的效果以页面配置为准。
<a name="yJ7fq"></a>

### 3. 页面配置中常用的配置项

| **属性**                     | **类型** | **默认值** | **描述**                                         |
| ---------------------------- | -------- | ---------- | ------------------------------------------------ |
| navigationBarBackgroundColor | HexColor | #000000    | 当前页面导航栏背景颜色，如 #000000               |
| navigationBarTextStyle       | String   | white      | 当前页面导航栏标题颜色，仅支持 black / white     |
| navigationBarTitleText       | String   | <br />     | 当前页面导航栏标题文字内容                       |
| backgroundColor              | HexColor | #ffffff    | 当前页面窗口的背景色                             |
| backgroundTextStyle          | String   | dark       | 当前页面下拉 loading 的样式，仅支持 dark / light |
| enablePullDownRefresh        | Boolean  | false      | 是否为当前页面开启下拉刷新的效果                 |
| onReachBottomDistance        | Number   | 50         | 页面上拉触底事件触发时距页面底部距离，单位为 px  |

<a name="vKK5t"></a>

## 网络数据请求

<a name="R822m"></a>

### 1. 小程序中网络数据请求的限制

出于安全性方面的考虑，小程序官方对数据接口的请求做出了如下两个限制：

1. 只能请求 HTTPS 类型的接口
2. 必须将接口的域名添加到信任列表中

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689564798850-1bb64277-76fb-45ef-b8c5-ff395f26f5af.png#averageHue=%23f1eded&clientId=ud24e9138-99cb-4&from=paste&height=644&id=u26315aa4&originHeight=644&originWidth=499&originalType=binary&ratio=1&rotation=0&showTitle=false&size=37498&status=done&style=none&taskId=uc40e9008-786b-4008-96c3-cfd7f45b962&title=&width=499)
<a name="Ukmgs"></a>

### 2. 配置 request 合法域名

需求描述：假设在自己的微信小程序中，希望请求 [https://www.escook.cn/](https://www.escook.cn/) 域名下的接口<br />配置步骤：登录微信小程序管理后台 -> 开发 -> 开发设置 -> 服务器域名 -> 修改 request 合法域名

注意事项：

1. 域名只支持 https 协议
2. 域名不能使用 IP 地址或 localhost
3. 域名必须经过 ICP 备案
4. 服务器域名一个月内最多可申请 5 次修改
   <a name="RgloP"></a>

### 3. 发起 GET 请求

调用微信小程序提供的 wx.request() 方法，可以发起 GET 数据请求，示例代码如下：<br />**wx是一个顶级的对象，和JavaScript的window一样**<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689564832484-f7283497-4268-4303-a9f9-47115ca9f24b.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=500&id=u659ea7bd&originHeight=500&originWidth=861&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32007&status=done&style=none&taskId=ua8410b0e-bff2-452e-b68e-e791e5f5ac2&title=&width=861)
<a name="h6AcX"></a>

### 4. 发起 POST 请求

调用微信小程序提供的 wx.request() 方法，可以发起 POST 数据请求，示例代码如下：<br />这里的数据参数都是data。也是跟axios不一样的地方<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689564874914-7f1728ab-5c17-4acf-a8d7-5cee6e5825b1.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=500&id=ueeeefdac&originHeight=500&originWidth=871&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32599&status=done&style=none&taskId=u6b50a7c3-f80a-4ae7-93ea-193f6dd31e7&title=&width=871)
<a name="KPdkm"></a>

### 5. 在页面刚加载时请求数据

在很多情况下，我们需要在页面刚加载的时候，自动请求一些初始化的数据。此时需要在页面的 onLoad 事件中调用获取数据的函数，示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689564889128-c29faf3f-0f63-4988-8cf5-fa8dd44bf651.png#averageHue=%23fdfcfb&clientId=ud24e9138-99cb-4&from=paste&height=687&id=u23afbe56&originHeight=687&originWidth=1064&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61661&status=done&style=none&taskId=u02532d76-d48c-4faa-9f2d-4c6dd6437a1&title=&width=1064)
<a name="kdySA"></a>

### 6. 跳过 request 合法域名校验

如果后端程序员仅仅提供了 http 协议的接口、暂时没有提供 https 协议的接口。<br />此时为了不耽误开发的进度，我们可以在微信开发者工具中，临时开启「开发环境不校验请求域名、TLS 版本及 HTTPS 证书」选项，跳过 request 合法域名的校验。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689564928984-12e05583-d3fd-4a22-8d61-5e5d495e2f82.png#averageHue=%23ede7e7&clientId=ud24e9138-99cb-4&from=paste&height=589&id=ub7faaf4d&originHeight=589&originWidth=499&originalType=binary&ratio=1&rotation=0&showTitle=false&size=46349&status=done&style=none&taskId=u059db2b2-739f-49db-8faf-bc7704e7769&title=&width=499)<br />注意：跳过 request 合法域名校验的选项，仅限在开发与调试阶段使用！
<a name="KhQIk"></a>

### 7. 关于跨域和 Ajax 的说明

跨域问题只存在于基于浏览器的 Web 开发中。由于小程序的宿主环境不是浏览器，而是微信客户端，所以小程序中不存在跨域的问题。<br />Ajax 技术的核心是依赖于浏览器中的 XMLHttpRequest 这个对象，由于小程序的宿主环境是微信客户端，所以小程序中不能叫做“发起 Ajax 请求”，而是叫做“发起网络数据请求”。
<a name="qSZwK"></a>

# 小程序 - 视图与逻辑

<a name="HE8rF"></a>

## 页面导航

<a name="qf6Mt"></a>

### 1. 什么是页面导航

页面导航指的是页面之间的相互跳转。例如，**浏览器**中实现页面导航的方式有如下两种：

1. <a> 链接
2. location.href
   <a name="MUqaW"></a>

### 2. 小程序中实现页面导航的两种方式

-  声明式导航
   - 在页面上声明一个 <navigator> 导航组件
   - 通过点击 <navigator> 组件实现页面跳转
-  编程式导航
   - 调用小程序的导航 API，实现页面的跳转
     <a name="z9QOX"></a>

### 声明式导航

<a name="Vx3dq"></a>

#### 1. 导航到 tabBar 页面

tabBar 页面指的是被配置为 tabBar 的页面。<br />在使用 <navigator> 组件跳转到指定的 tabBar 页面时，需要指定 url 属性和 open-type 属性，其中：

- url 表示要跳转的页面的地址，必须以 / 开头
- open-type 表示跳转的方式，必须为 switchTab

示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689576041709-7540d6db-48e3-4732-a7d6-6711d64837a0.png#averageHue=%230d1123&clientId=ud24e9138-99cb-4&from=paste&height=130&id=ude5c17d1&originHeight=130&originWidth=988&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10145&status=done&style=none&taskId=ub8db673e-8dae-4ef2-9aaa-a71b129720f&title=&width=988)
<a name="Sghsi"></a>

#### 2. 导航到非 tabBar 页面

非 tabBar 页面指的是没有被配置为 tabBar 的页面。<br />在使用 <navigator> 组件跳转到普通的非 tabBar 页面时，则需要指定 url 属性和 open-type 属性，其中：

- url 表示要跳转的页面的地址，必须以 / 开头
- open-type 表示跳转的方式，必须为 navigate

示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689576258841-9c42cd3f-a20f-474e-a164-7daeae525b33.png#averageHue=%230d1123&clientId=ud24e9138-99cb-4&from=paste&height=130&id=u5f9726cb&originHeight=130&originWidth=920&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9547&status=done&style=none&taskId=u552e2636-f733-41ba-b2c6-dd283e3e579&title=&width=920)<br />注意：为了简便，在导航到非 tabBar 页面时，open-type="navigate" 属性可以省略。但是导航到tabBar页面必须加前面那个 switchTab

<a name="h15fn"></a>

#### 3. 后退导航

如果要后退到上一页面或多级页面，则需要指定 open-type 属性和 delta 属性，其中：

-  open-type 的值必须是 navigateBack，表示要进行后退导航
-  delta 的值必须是数字，表示要后退的层级

示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689576342490-40412a18-4172-4dc0-a622-a788b4715add.png#averageHue=%230d1123&clientId=ud24e9138-99cb-4&from=paste&height=130&id=uc24aa5aa&originHeight=130&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8307&status=done&style=none&taskId=u69c3ab92-32e9-45ba-9a63-e3c3baf3ffc&title=&width=850)<br />注意：为了简便，如果只是后退到上一页面，则可以省略 delta 属性，因为其默认值就是 1。
<a name="Hbvfs"></a>

### 编程式导航

<a name="ylUhD"></a>

#### 1. 导航到 tabBar 页面

调用 wx.switchTab(Object object) 方法，可以跳转到 tabBar 页面。其中 Object 参数对象的属性列表如下：

| **属性** | **类型** | **是否必选** | **说明**                                         |
| -------- | -------- | ------------ | ------------------------------------------------ |
| url      | string   | 是           | 需要跳转的 tabBar 页面的路径，路径后不能带参数   |
| success  | function | 否           | 接口调用成功的回调函数                           |
| fail     | function | 否           | 接口调用失败的回调函数                           |
| complete | function | 否           | 接口调用结束的回调函数（调用成功、失败都会执行） |

示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689576383225-23faf4e7-63fc-4f25-83f4-1f0ff2f1cb37.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=426&id=u6216d319&originHeight=426&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24233&status=done&style=none&taskId=u50eba6dc-8ba3-4426-873b-ee5ab3924df&title=&width=850)
<a name="kjeaE"></a>

#### 2. 导航到非 tabBar 页面

调用 wx.navigateTo(Object object) 方法，可以跳转到非 tabBar 的页面。其中 Object 参数对象的属性列表如下：

| **属性** | **类型** | **是否必选** | **说明**                                           |
| -------- | -------- | ------------ | -------------------------------------------------- |
| url      | string   | 是           | 需要跳转到的非 tabBar 页面的路径，路径后可以带参数 |
| success  | function | 否           | 接口调用成功的回调函数                             |
| fail     | function | 否           | 接口调用失败的回调函数                             |
| complete | function | 否           | 接口调用结束的回调函数（调用成功、失败都会执行）   |

示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689577011368-5448892a-1693-4ecc-8d9d-12ab5edecce4.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=426&id=u213388cd&originHeight=426&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22309&status=done&style=none&taskId=u58e29161-9c21-4c37-88f3-c0e51b2070f&title=&width=850)
<a name="B6unJ"></a>

#### 3. 后退导航

调用 wx.navigateBack(Object object) 方法，可以返回上一页面或多级页面。其中 Object 参数对象可选的属性列表如下：

| **属性** | **类型** | **默认值** | **是否必选** | **说明**                                              |
| -------- | -------- | ---------- | ------------ | ----------------------------------------------------- |
| delta    | number   | 1          | 否           | 返回的页面数，如果 delta 大于现有页面数，则返回到首页 |
| success  | function |            |              |                                                       |

 | 否 | 接口调用成功的回调函数 |
| fail | function | 

 | 否 | 接口调用失败的回调函数 |
| complete | function | 

 | 否 | 接口调用结束的回调函数（调用成功、失败都会执行） |

示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689577049943-e2535012-70a6-4139-8a52-564cafae0190.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=314&id=uec0da2af&originHeight=314&originWidth=756&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14912&status=done&style=none&taskId=ue048cbff-275e-4c41-a2a3-8891b58a0a8&title=&width=756)
<a name="MDVWA"></a>

### 导航传参

<a name="m19g0"></a>

#### 1. 声明式导航传参

navigator 组件的 url 属性用来指定将要跳转到的页面的路径。同时，路径的后面还可以携带参数：

-  参数与路径之间使用 ? 分隔
-  参数键与参数值用 = 相连
-  不同参数用 & 分隔

代码示例如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689577091649-a7ea0455-2ea7-410b-a21e-9de1b7b76a77.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=130&id=u0cfc17ad&originHeight=130&originWidth=856&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9611&status=done&style=none&taskId=u4b94521f-ec95-43ce-94e3-55a91b208d6&title=&width=856)
<a name="wczG3"></a>

#### 2. 编程式导航传参

调用 wx.navigateTo(Object object) 方法跳转页面时，也可以携带参数，代码示例如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689577107398-64625f17-abb7-4808-984b-8bd8ec605907.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=426&id=u3063f030&originHeight=426&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25076&status=done&style=none&taskId=u45415e6e-9113-4b57-91dd-738d049b715&title=&width=850)
<a name="wScQM"></a>

#### 3. 在 onLoad 中接收导航参数

通过声明式导航传参或编程式导航传参所携带的参数，可以直接在 onLoad 事件（生命周期函数）中直接获取到，示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689577122957-c27f1033-2236-45f1-b734-a42df0223ee2.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=352&id=u44deaa94&originHeight=352&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18458&status=done&style=none&taskId=ud327e75f-2b74-4d89-bfb4-0f4e24edac9&title=&width=850)
<a name="EVHBa"></a>

## 页面事件

<a name="p8xaT"></a>

### 下拉刷新事件

<a name="mvRIS"></a>

#### 1. 什么是下拉刷新

下拉刷新是移动端的专有名词，指的是通过手指在屏幕上的下拉滑动操作，从而重新加载页面数据的行为。
<a name="j0FCG"></a>

#### 2. 启用下拉刷新

启用下拉刷新有两种方式：

- 全局开启下拉刷新
  - 在 app.json 的 window 节点中，将 enablePullDownRefresh 设置为 true
- 局部开启下拉刷新
  - 在页面的 .json 配置文件中，将 enablePullDownRefresh 设置为 true

在实际开发中，推荐使用第 2 种方式，为需要的页面单独开启下拉刷新的效果。

<a name="N8Jcg"></a>

#### 3. 配置下拉刷新窗口的样式

在全局或页面的 .json 配置文件中，通过 backgroundColor 和 backgroundTextStyle 来配置下拉刷新窗口的样式，其中：

-  backgroundColor 用来配置下拉刷新窗口的背景颜色，仅支持16 进制的颜色值
-  backgroundTextStyle 用来配置下拉刷新 loading 的样式，仅支持 dark 和 light
   <a name="m8Tfe"></a>

#### 4. 监听页面的下拉刷新事件

在页面的 .js 文件中，通过 onPullDownRefresh() 函数即可监听当前页面的下拉刷新事件。例如，在页面的 wxml 中有如下的 UI 结构，点击按钮可以让 count 值自增 +1：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689577215225-411a9b78-a530-43a6-af74-fe739b32cd8b.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=463&id=u0ce17dca&originHeight=463&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23986&status=done&style=none&taskId=u0342f59c-5eab-45b4-b547-4da9cbd6612&title=&width=850)<br />在触发页面的下拉刷新事件的时候，如果要把 count 的值重置为 0，示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689577244324-2bdd6084-8977-4105-9971-580304fe4001.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=389&id=uf77e08d0&originHeight=389&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16486&status=done&style=none&taskId=ucb307ea5-9ccc-458f-88e2-c5fe3a3ebbe&title=&width=850)
<a name="B8xt5"></a>

#### 5. 停止下拉刷新的效果

当处理完下拉刷新后，下拉刷新的 loading 效果会一直显示，不会主动消失（手机版的不会。。。很奇怪），所以需要手动隐藏下拉刷新的 loading 效果。此时，调用 wx.stopPullDownRefresh() 可以停止当前页面的下拉刷新。示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689577262871-d59b282f-2b24-40e5-9472-d75cc215a71e.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=463&id=ue27a339e&originHeight=463&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26130&status=done&style=none&taskId=u4275672e-947f-4986-b241-7d7893c8366&title=&width=850)
<a name="y8DlE"></a>

### 上拉触底事件

<a name="biDcY"></a>

#### 1. 什么是上拉触底

上拉触底是移动端的专有名词，通过手指在屏幕上的上拉滑动操作，从而加载更多数据的行为。
<a name="jRoh6"></a>

#### 2. 监听页面的上拉触底事件

在页面的 .js 文件中，通过 onReachBottom() 函数即可监听当前页面的上拉触底事件。示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689577310878-3f74fa17-d70d-4a3c-8c6b-93ec4ca26ce1.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=315&id=u0035a93e&originHeight=315&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15666&status=done&style=none&taskId=u286f44d7-78c9-445e-a68c-463aec68af3&title=&width=850)<br />**这里需要做节流的处理**
<a name="aH2M9"></a>

#### 3. 配置上拉触底距离

上拉触底距离指的是触发上拉触底事件时，滚动条距离页面底部的距离。<br />可以在全局或页面的 .json 配置文件中，通过 onReachBottomDistance 属性来配置上拉触底的距离。<br />小程序默认的触底距离是 50px，在实际开发中，可以根据自己的需求修改这个默认值。
<a name="vswrE"></a>

#### 上拉触底案例

<a name="KzcoJ"></a>

##### 1. 案例效果展示

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689578454472-c9f343d6-f689-44f3-a5cc-c0952f829847.png#averageHue=%23effa92&clientId=ud24e9138-99cb-4&from=paste&height=698&id=u2110b0b3&originHeight=698&originWidth=394&originalType=binary&ratio=1&rotation=0&showTitle=false&size=229933&status=done&style=none&taskId=ueadb1662-4ba6-46ce-b604-ea11fafd779&title=&width=394)
<a name="A4Yu1"></a>

##### 2. 案例的实现步骤

1. 定义获取随机颜色的方法
2. 在页面加载时获取初始数据
3. 渲染 UI 结构并美化页面效果
4. 在上拉触底时调用获取随机颜色的方法
5. 添加 loading 提示效果
6. 对上拉触底进行节流处理
   <a name="PupSG"></a>

##### 3. 步骤1 - 定义获取随机颜色的方法

这里让我想到了不能用push，这个跟react的也太像了<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689578487155-8f0f8c6b-cb45-4077-a5fe-9f61e18d82b8.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=648&id=uc700b561&originHeight=648&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35950&status=done&style=none&taskId=u1683b1c6-c4df-4ea8-9020-b5ab78363c8&title=&width=850)
<a name="TFEc6"></a>

##### 3. 步骤2 - 在页面加载时获取初始数据

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689578507655-d94e3c83-61e9-4778-8e5e-88b350eeb321.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=315&id=u315c24db&originHeight=315&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13121&status=done&style=none&taskId=ucfa1604b-ed1b-4801-aaa2-286c2740c83&title=&width=850)
<a name="ELLV8"></a>

##### 3. 步骤3 - 渲染 UI 结构并美化页面效果

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689578518566-063f4489-e5d4-4810-9bad-af6ec8259240.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=611&id=uad0660ac&originHeight=611&originWidth=1030&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39478&status=done&style=none&taskId=uaab43b67-5d7a-4b7b-ba59-91ed8de00fb&title=&width=1030)
<a name="dyMVm"></a>

##### 3. 步骤4 - 上拉触底时获取随机颜色

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689578533937-c59bad99-4c5d-4952-9857-e378944f419a.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=352&id=uc212ec34&originHeight=352&originWidth=883&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17649&status=done&style=none&taskId=u5bcf5f05-9615-4f0c-94c1-0fa884c052e&title=&width=883)
<a name="MIGCo"></a>

##### 3. 步骤5 - 添加 loading 提示效果

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689578546648-64ed8fe3-a28d-4a92-adae-218fc684b29f.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=500&id=u004cc6ce&originHeight=500&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30959&status=done&style=none&taskId=u74fb6540-1edd-4c27-84f5-5685afc8a4a&title=&width=850)
<a name="kBIcG"></a>

##### 3. 步骤6 - 对上拉触底进行节流处理

1. 在 data 中定义 isloading 变量  作为节流阀
   1. false 表示当前没有进行任何数据请求
   2. true 表示当前正在进行数据请求
2. 在 getColors() 方法中修改 isloading 节流阀的值
   1. 在刚调用 getColors 时将节流阀设置 true
   2. 在网络请求的 complete 回调函数中，将节流阀重置为 false
3. 在 onReachBottom 中判断节流阀的值，从而对数据请求进行节流控制
   1. 如果节流阀的值为 true，则阻止当前请求
   2. 如果节流阀的值为 false，则发起数据请求
      <a name="gTnhB"></a>

## 生命周期

<a name="Mz1BT"></a>

### 1. 什么是生命周期

生命周期（Life Cycle）是指一个对象从创建 -> 运行 -> 销毁的整个阶段，强调的是一个时间段。例如：

- 张三出生，表示这个人生命周期的开始
- 张三离世，表示这个人生命周期的结束
- 中间张三的一生，就是张三的生命周期

我们可以把每个小程序运行的过程，也概括为生命周期：

- 小程序的启动，表示生命周期的开始
- 小程序的关闭，表示生命周期的结束
- 中间小程序运行的过程，就是小程序的生命周期
  <a name="p1CX5"></a>

### 2. 生命周期的分类

在小程序中，生命周期分为两类，分别是：

1.  应用生命周期
    1. 特指小程序从启动 -> 运行 -> 销毁的过程
2.  页面生命周期
    1. 特指小程序中，每个页面的加载 -> 渲染 -> 销毁的过程

其中，**页面**的生命周期范围较小，**应用程序**的生命周期范围较大，如图所示：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689578635102-f5e30bc0-dfc4-4f17-9da6-e7701e952c03.png#averageHue=%23f5e9e9&clientId=ud24e9138-99cb-4&from=paste&height=210&id=u8494ae25&originHeight=210&originWidth=1800&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38345&status=done&style=none&taskId=u6e9e0b04-aa41-4d0d-bf8b-e4ac7ac22a3&title=&width=1800)
<a name="qgzUG"></a>

### 3. 什么是生命周期函数

生命周期函数：是由小程序框架提供的内置函数，会伴随着生命周期，自动按次序执行。<br />生命周期函数的作用：允许程序员在特定的时间点，执行某些特定的操作。例如，页面刚加载的时候，可以在 onLoad 生命周期函数中初始化页面的数据。<br />注意：**生命周期强调的是时间段，生命周期函数强调的是时间点**。
<a name="MNx9F"></a>

### 4. 生命周期函数的分类

小程序中的生命周期函数分为两类，分别是：

1.  应用的生命周期函数
    1. 特指小程序从启动 -> 运行 -> 销毁期间依次调用的那些函数
2.  页面的生命周期函数
    1. 特指小程序中，每个页面从加载 -> 渲染 -> 销毁期间依次调用的那些函数
       <a name="iZdSu"></a>

### 5. 应用的生命周期函数

小程序的应用生命周期函数需要在 app.js 中进行声明，示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689578702889-5d2575cd-bac3-4d9d-81a4-37beacfec4c9.png#averageHue=%230c1022&clientId=ud24e9138-99cb-4&from=paste&height=426&id=u9942c7ba&originHeight=426&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30497&status=done&style=none&taskId=ubf49de17-1723-4461-8625-cfe792a7409&title=&width=850)<br />前台和后台的区别：

- 前台，其实就是打开小程序，你能看到这个小程序页面
- 后台，其实就是最小化小程序，把它缩小了
  <a name="gAVTG"></a>

### 6. 页面的生命周期函数

小程序的页面生命周期函数需要在页面的 .js 文件中进行声明，示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689578733013-8b8fad19-d24a-4a11-bf9f-7cff8fb7362f.png#averageHue=%230c1122&clientId=ud24e9138-99cb-4&from=paste&height=389&id=u19b32712&originHeight=389&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33179&status=done&style=none&taskId=u97a0ef5d-2816-421b-a8cb-ee31d7fe909&title=&width=850)

<a name="xkBlQ"></a>

## WXS 脚本

WXS（WeiXin Script）是小程序独有的一套脚本语言，结合 WXML，可以构建出页面的结构。
<a name="BsJcj"></a>

### 基础语法

<a name="hHCT4"></a>

#### 1. 内嵌 wxs 脚本

wxs 代码可以编写在 wxml 文件中的 <wxs> 标签内，就像 Javascript 代码可以编写在 html 文件中的 <script> 标签内一样。<br />wxml 文件中的每个 <wxs></wxs> 标签，必须提供 module 属性，用来指定当前 wxs 的模块名称，方便在 wxml 中访问模块中的成员：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689578783380-c10d7379-40ef-46cf-a104-b39f38103497.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=389&id=u3dee51cd&originHeight=389&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21635&status=done&style=none&taskId=u36cc1677-b033-4cd3-a765-fda84f8da04&title=&width=850)
<a name="owXDc"></a>

#### 2. 定义外联的 wxs 脚本

wxs 代码还可以编写在以 .wxs 为后缀名的文件内，就像 javascript 代码可以编写在以 .js 为后缀名的文件中一样。示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689578947859-3b112293-d9a9-4e9a-a78c-60a50feaa618.png#averageHue=%230c1021&clientId=ud24e9138-99cb-4&from=paste&height=389&id=u545a6d49&originHeight=389&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15261&status=done&style=none&taskId=u02767759-892e-418d-926d-1cba14e6fe5&title=&width=850)
<a name="L7QVF"></a>

#### 3. 使用外联的 wxs 脚本

在 wxml 中引入外联的 wxs 脚本时，必须为 <wxs> 标签添加 module 和 src 属性，其中：

-  module 用来指定模块的名称
-  src 用来指定要引入的脚本的路径，且必须是相对路径

示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689578979780-95ebfe23-e34e-4ff6-99c5-f31a05639b68.png#averageHue=%230d1123&clientId=ud24e9138-99cb-4&from=paste&height=278&id=u1ca1093e&originHeight=278&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19444&status=done&style=none&taskId=u13b56100-7d13-414c-8ba5-4ccab41a753&title=&width=850)
<a name="DTbNF"></a>

### WXS 的特点

<a name="wOYsy"></a>

#### 1. 与 JavaScript 不同

为了降低 wxs（WeiXin Script）的学习成本， wxs 语言在设计时借大量鉴了 JavaScript 的语法。但是本质上，wxs 和 JavaScript 是完全不同的两种语言！
<a name="vs4RK"></a>

#### 2. 不能作为组件的事件回调

wxs 典型的应用场景就是“过滤器”，经常配合 Mustache 语法进行使用，例如：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689579010645-451e0626-896a-4939-bdc0-dd46d988e06a.png#averageHue=%230c1122&clientId=ud24e9138-99cb-4&from=paste&height=130&id=u57c5d17c&originHeight=130&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5972&status=done&style=none&taskId=u907eed21-6c3c-4596-934e-250132ccf9d&title=&width=850)<br />但是，在 wxs 中定义的函数不能作为组件的事件回调函数。例如，下面的用法是错误的：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689579022084-ec62e2e1-cf06-4390-8b98-492aa32e5786.png#averageHue=%230c1122&clientId=ud24e9138-99cb-4&from=paste&height=130&id=ud2f5c525&originHeight=130&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6725&status=done&style=none&taskId=u851a3188-348a-4df6-bd00-2e7251b9969&title=&width=850)
<a name="cVNR4"></a>

#### 3. 隔离性

隔离性指的是 wxs 的运行环境和其他 JavaScript 代码是隔离的。体现在如下两方面：

1. wxs 不能调用 js 中定义的函数
2. wxs 不能调用小程序提供的 API
   <a name="jWAB6"></a>

#### 4. 性能好

在 iOS 设备上，小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍<br />在 android 设备上，二者的运行效率无差异
<a name="k2uTC"></a>

# 小程序 - 基础加强

<a name="ymmV7"></a>

## 自定义组件

<a name="nlTp7"></a>

### 组件的创建与引用

<a name="Q2Ya8"></a>

#### 1. 创建组件

1. 在项目的根目录中，鼠标右键，创建 components -> 组件名 文件夹
2. 在新建的 components -> 组件名 文件夹上，鼠标右键，点击“新建 Component”
3. 键入组件的名称之后回车，会自动生成组件对应的 4 个文件，后缀名分别为 .js，.json， .wxml 和 .wxss

注意：为了保证目录结构的清晰，建议把不同的组件，存放到单独目录中，例如：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689637093611-cfd57f75-10bd-49d8-8a50-d11ef242f788.png#averageHue=%23ebdddb&clientId=ubfe5c909-99ad-4&from=paste&height=307&id=uf1a4b6ec&originHeight=307&originWidth=297&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20287&status=done&style=none&taskId=u97ebccbd-348e-442b-8791-17f3484e5bf&title=&width=297)
<a name="UjQNY"></a>

#### 2. 引用组件

组件的引用方式分为“局部引用”和“全局引用”，顾名思义：

- 局部引用：组件只能在当前被引用的页面内使用
- 全局引用：组件可以在每个小程序页面中使用
  <a name="l10zl"></a>

#### 3. 局部引用组件

在页面的 .json 配置文件中引用组件的方式，叫做“局部引用”。通过usingComponents属性进行引用。示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689637157576-7ef673de-8095-4fec-8dce-d4952463b94e.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=426&id=u1689c304&originHeight=426&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19733&status=done&style=none&taskId=u2e6ead9b-8ce8-4648-91e4-dd2e838ed8a&title=&width=850)
<a name="mLXSV"></a>

#### 4. 全局引用组件

在 app.json 全局配置文件中引用组件的方式，叫做“全局引用”。示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689637200692-486ef2e6-4015-437d-8cfc-b2fb5f40b40a.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=500&id=u882c3f73&originHeight=500&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29095&status=done&style=none&taskId=u9b40fec5-089c-4e23-b19b-75ae8e0a764&title=&width=850)
<a name="VTBSQ"></a>

#### 5. 全局引用 VS 局部引用

根据组件的使用频率和范围，来选择合适的引用方式：

- 如果某组件在多个页面中经常被用到，建议进行“全局引用”
- 如果某组件只在特定的页面中被用到，建议进行“局部引用”
  <a name="DcH3U"></a>

#### 6. 组件和页面的区别

从表面来看，组件和页面都是由 .js、.json、.wxml 和 .wxss 这四个文件组成的。但是，**组件**和**页面**的 .js 与 .json 文件有明显的不同：

- 组件的 .json 文件中需要声明 "component": true 属性
- 组件的 .js 文件中调用的是 Component() 函数
- 组件的事件处理函数需要定义到 methods 节点中
  <a name="f5Ml8"></a>

### 样式

<a name="fYYU6"></a>

#### 1. 组件样式隔离

默认情况下，**自定义组件的样式只对当前组件生效**，不会影响到组件之外的 UI 结构，如图所示：

- 组件 A 的样式不会影响组件 C 的样式
- 组件 A 的样式不会影响小程序页面的样式
- 小程序页面的样式不会影响组件 A 和 C 的样式

好处：

1. 防止**外界的样式**影响**组件内部**的样式
2. 防止**组件**的样式破坏**外界**的样式

其实可以理解为一个沙箱环境
<a name="aoDVq"></a>

#### 2. 组件样式隔离的注意点

- app.wxss 中的全局样式对组件无效
- 只有 class 选择器会有样式隔离效果，id 选择器、属性选择器、标签选择器不受样式隔离的影响

建议：在组件和引用组件的页面中建议使用 class 选择器，不要使用 id、属性、标签选择器！
<a name="ApxY8"></a>

#### 3. 修改组件的样式隔离选项

默认情况下，自定义组件的样式隔离特性能够防止组件内外样式互相干扰的问题。但有时，我们希望在外界能够控制组件内部的样式，此时，可以通过 styleIsolation 修改组件的样式隔离选项，用法如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689637492951-01060ede-219c-491d-a886-d2257f576c83.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=500&id=ub02242dd&originHeight=500&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22289&status=done&style=none&taskId=uc5eaaf5e-44e0-47bb-83ba-3e19d0550a9&title=&width=850)
<a name="AyIPi"></a>

#### 4. styleIsolation 的可选值

| **可选值**   | **默认值** | **描述**                                                     |
| ------------ | ---------- | ------------------------------------------------------------ |
| isolated     | 是         | 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响 |
| apply-shared | 否         | 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面 |
| shared       | 否         | 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 apply-shared 或 shared 的自定义组件 |

<a name="n7F3g"></a>

### 数据、方法和属性

<a name="Hw5Am"></a>

#### 1. data 数据

在小程序组件中，用于组件模板渲染的私有数据，需要定义到 data 节点中，示例如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689638353719-9c22dec4-edab-45d7-8736-f75916aed695.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=453&id=u6c1879c5&originHeight=453&originWidth=945&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13939&status=done&style=none&taskId=u3325158b-3d30-4e4d-a539-a65a5681671&title=&width=945)
<a name="UPxEF"></a>

#### 2. methods 方法

在小程序组件中，事件处理函数和自定义方法需要定义到 methods 节点中，示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689638369023-c41e8fc6-9b6b-4346-951c-a8cfad674b09.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=597&id=uafd76547&originHeight=597&originWidth=945&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39239&status=done&style=none&taskId=u2f80c28d-ef76-41b6-a9cf-5568b44d0f0&title=&width=945)
<a name="onb3f"></a>

#### 3. properties 属性

在小程序组件中，properties 是组件的对外属性，用来接收外界传递到组件中的数据，示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689638403276-9b143b56-5ab9-435a-97d9-a48699baf871.png#averageHue=%230c1022&clientId=ubfe5c909-99ad-4&from=paste&height=525&id=u77b07b84&originHeight=525&originWidth=945&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36726&status=done&style=none&taskId=uf6d55f59-f855-498c-abc2-e1f3db57b5a&title=&width=945)
<a name="ReHBY"></a>

#### 4. data 和 properties 的区别

在小程序的组件中，properties 属性和 data 数据的用法相同，它们都是可读可写的，只不过：

- data 更倾向于存储组件的私有数据
- properties 更倾向于存储外界传递到组件中的数据
  <a name="qIHEk"></a>

#### 5. 使用 setData 修改 properties 的值

由于 data 数据和 properties 属性在本质上没有任何区别，因此 properties 属性的值也可以用于页面渲染，或使用 setData 为 properties 中的属性重新赋值，示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689638487656-52fbe914-dfbd-4e6a-883c-e2e26e44f951.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=489&id=uccc73cc2&originHeight=489&originWidth=945&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31204&status=done&style=none&taskId=u6f1164e6-fe10-4fe8-ad34-afd1ab40872&title=&width=945)
<a name="GUgxU"></a>

### 数据监听器

<a name="HR7fV"></a>

#### 1. 什么是数据监听器

数据监听器用于监听和响应任何属性和数据字段的变化，从而执行特定的操作。它的作用类似于 vue 中的 watch 侦听器。在小程序组件中，数据监听器的基本语法格式如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689638529647-00dce21c-f109-4d46-a6e7-2aed320e69a9.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=345&id=ueaed1b1b&originHeight=345&originWidth=945&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14426&status=done&style=none&taskId=u4d07aff7-74bc-446f-8f9e-28f3fb66819&title=&width=945)
<a name="AHI4z"></a>

#### 2. 数据监听器的基本用法

组件的 UI 结构如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689638548899-d3eac02c-f771-4d27-a56b-336fcb037250.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=237&id=uc830809d&originHeight=237&originWidth=945&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18746&status=done&style=none&taskId=u467c81ac-0717-48a8-9a94-14314aecce4&title=&width=945)<br />组件的 .js 文件代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689638559539-d26b6b5d-f600-4e35-8f0b-a4234fcddf64.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=525&id=u4ec2c22d&originHeight=525&originWidth=945&originalType=binary&ratio=1&rotation=0&showTitle=false&size=37556&status=done&style=none&taskId=u78932822-b6b1-4ba5-a97f-57cb0e3cbee&title=&width=945)
<a name="KypTj"></a>

#### 3. 监听对象属性的变化

数据监听器支持监听对象中单个或多个属性的变化，示例语法如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689638698491-a7b06fbe-596f-40ab-87ee-04cc7e05a7ad.png#averageHue=%230c1122&clientId=ubfe5c909-99ad-4&from=paste&height=489&id=u5f21afbe&originHeight=489&originWidth=945&originalType=binary&ratio=1&rotation=0&showTitle=false&size=37109&status=done&style=none&taskId=u6078b814-a5c4-41e0-9bc1-5804388456e&title=&width=945)
<a name="E4H2y"></a>

### 纯数据字段

<a name="rKzKo"></a>

#### 1. 什么是纯数据字段

概念：纯数据字段指的是那些不用于界面渲染的 data 字段。<br />应用场景：例如有些情况下，某些 data 中的字段既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。带有这种特性的 data 字段适合被设置为纯数据字段。<br />好处：纯数据字段有助于提升页面更新的性能。
<a name="sGZzI"></a>

#### 2. 使用规则

在 Component 构造器的 options 节点中，指定 pureDataPattern 为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段，示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689638778485-4b430cc7-5940-4fe8-86ed-19a135379a31.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=453&id=ue470c18a&originHeight=453&originWidth=945&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22538&status=done&style=none&taskId=u1d0ae16d-b41d-4a72-afa0-eb00619f22d&title=&width=945)
<a name="w1MAC"></a>

### 组件的生命周期

<a name="uCFt2"></a>

#### 1. 组件全部的生命周期函数

小程序组件可用的全部生命周期如下表所示：

| **生命周期函数** | **参数**     | **描述说明**                             |
| ---------------- | ------------ | ---------------------------------------- |
| created          | 无           | 在组件实例刚刚被创建时执行               |
| attached         | 无           | 在组件实例进入页面节点树时执行           |
| ready            | 无           | 在组件在视图层布局完成后执行             |
| moved            | 无           | 在组件实例被移动到节点树另一个位置时执行 |
| detached         | 无           | 在组件实例被从页面节点树移除时执行       |
| error            | Object Error | 每当组件方法抛出错误时执行               |

<a name="J7RWk"></a>

#### 2. 组件主要的生命周期函数

在小程序组件中，最重要的生命周期函数有 3 个，分别是 created、attached、detached。它们各自的特点如下：

-  组件实例刚被创建好的时候，created 生命周期函数会被触发
   - 此时还不能调用 setData
   - 通常在这个生命周期函数中，只应该用于给组件的 this 添加一些自定义的属性字段
-  在组件完全初始化完毕、进入页面节点树后， attached 生命周期函数会被触发
   - 此时， this.data 已被初始化完毕
   - 这个生命周期很有用，绝大多数初始化的工作可以在这个时机进行（例如发请求获取初始数据）
-  在组件离开页面节点树后， detached 生命周期函数会被触发
   - 退出一个页面时，会触发页面内每个自定义组件的 detached 生命周期函数
   - 此时适合做一些清理性质的工作
     <a name="zyPFS"></a>

#### 3. lifetimes 节点

在小程序组件中，生命周期函数可以直接定义在 Component 构造器的第一级参数中，可以在 lifetimes 字段内进行声明（这是推荐的方式，其优先级最高）。示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689638932507-0e9ca86d-02ea-4177-a5b0-21e14b3ea9cb.png#averageHue=%230c1122&clientId=ubfe5c909-99ad-4&from=paste&height=452&id=u8381e3af&originHeight=452&originWidth=945&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38022&status=done&style=none&taskId=ub56a3eaf-4d94-4bf0-8a09-bfbbd26ef7d&title=&width=945)
<a name="JIF3C"></a>

### 组件所在页面的生命周期

<a name="gPDK0"></a>

#### 1. 什么是组件所在页面的生命周期

有时，自定义组件的行为依赖于页面状态的变化，此时就需要用到组件所在页面的生命周期。<br />例如：每当触发页面的 show 生命周期函数的时候，我们希望能够重新生成一个随机的 RGB 颜色值。在自定义组件中，组件所在页面的生命周期函数有如下 3 个，分别是：

| **生命周期函数** | **参数**    | **描述**                     |
| ---------------- | ----------- | ---------------------------- |
| show             | 无          | 组件所在的页面被展示时执行   |
| hide             | 无          | 组件所在的页面被隐藏时执行   |
| resize           | Object Size | 组件所在的页面尺寸变化时执行 |

组件所在页面的生命周期函数，需要定义在 pageLifetimes 节点中，示例代码如下：
<a name="H6tqT"></a>

#### 2. pageLifetimes 节点

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689639021679-fe55c5e8-0fe7-4a91-86cd-7fb336242ece.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=345&id=u344ea5cd&originHeight=345&originWidth=945&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19912&status=done&style=none&taskId=u7371b930-7306-4052-b796-d1813e49334&title=&width=945)
<a name="uailU"></a>

### 插槽

<a name="ir8FA"></a>

#### 1. 什么是插槽

在自定义组件的 wxml 结构中，可以提供一个 <slot> 节点（插槽），用于承载组件使用者提供的 wxml 结构。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689639079215-202225a9-7d19-4873-a86c-5bae2934bfbc.png#averageHue=%23e7e4f5&clientId=ubfe5c909-99ad-4&from=paste&height=452&id=u9d14d6f1&originHeight=452&originWidth=617&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35974&status=done&style=none&taskId=ub0f41706-02a3-4cb2-a930-02ef1fd228e&title=&width=617)
<a name="RIDUp"></a>

#### 2. 单个插槽

在小程序中，默认每个自定义组件中只允许使用一个 <slot> 进行占位，这种个数上的限制叫做单个插槽。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689639108929-0a7c2ede-ad5a-4891-a1b7-9505b9c34e1f.png#averageHue=%230d1123&clientId=ubfe5c909-99ad-4&from=paste&height=525&id=ub5b04c41&originHeight=525&originWidth=945&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40490&status=done&style=none&taskId=uf5d7eb1a-e434-4cb1-b523-042417766ca&title=&width=945)
<a name="hOyAN"></a>

#### 3. 启用多个插槽

在小程序的自定义组件中，需要使用多 <slot> 插槽时，可以在组件的 .js 文件中，通过如下方式进行启用。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689639150791-a298c9a1-b01c-4dc5-aaaa-d77979774718.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=345&id=u9e99201b&originHeight=345&originWidth=945&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17613&status=done&style=none&taskId=ua29eaf7c-bcd5-49fa-918a-848b0edd9cf&title=&width=945)
<a name="B0t5k"></a>

#### 4. 定义多个插槽

可以在组件的 .wxml 中使用多个 <slot> 标签，以不同的 name 来区分不同的插槽。示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689639170797-c1dc3ad6-016a-4c0d-a857-64eea2349eba.png#averageHue=%230c1122&clientId=ubfe5c909-99ad-4&from=paste&height=380&id=u2c29eaca&originHeight=380&originWidth=945&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27171&status=done&style=none&taskId=u4c111e58-88bb-4d39-8ddf-bcd086b5b20&title=&width=945)
<a name="KLU4m"></a>

#### 5. 使用多个插槽

在使用带有多个插槽的自定义组件时，需要用 slot 属性来将节点插入到不同的 <slot> 中。示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689639192000-eb90a2d9-5478-49aa-a58a-93dae94c23d7.png#averageHue=%230d1224&clientId=ubfe5c909-99ad-4&from=paste&height=345&id=u1cf36c58&originHeight=345&originWidth=945&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36602&status=done&style=none&taskId=ucd3a0b21-3a8e-4156-8588-4c2c7157c2b&title=&width=945)
<a name="QqNBM"></a>

### 父子组件之间的通信

<a name="RLANV"></a>

#### 1. 父子组件之间通信的 3 种方式

- 属性绑定
  - 用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容的数据
- 事件绑定
  - 用于子组件向父组件传递数据，可以传递任意数据
- 获取组件实例
  - 父组件还可以通过 this.selectComponent() 获取子组件实例对象
  - 这样就可以直接访问子组件的任意数据和方法
    <a name="Tb5N7"></a>

#### 2. 属性绑定

属性绑定用于实现父向子传值，而且只能传递普通类型的数据，无法将方法传递给子组件。父组件的示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689639271626-5f32ab0a-6625-4f97-8705-7a83e5365f84.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=425&id=uaaf5fe9f&originHeight=425&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23130&status=done&style=none&taskId=u941e5cd2-9303-44e7-9408-f9071853ae4&title=&width=943)<br />子组件在 properties 节点中声明对应的属性并使用。示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689639292204-0429a288-5267-47dc-96ad-b5ceba806f00.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=351&id=ue9a463b8&originHeight=351&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17032&status=done&style=none&taskId=u4f317b42-22b9-4428-9078-f87bd9d75e0&title=&width=943)
<a name="lWIjJ"></a>

#### 3. 事件绑定

事件绑定用于实现子向父传值，可以传递任何类型的数据。使用步骤如下：

1. 在父组件的 js 中，定义一个函数，这个函数即将通过自定义事件的形式，传递给子组件
2. 在父组件的 wxml 中，通过自定义事件的形式，将步骤 1 中定义的函数引用，传递给子组件
3. 在子组件的 js 中，通过调用 this.triggerEvent('自定义事件名称', { /* 参数对象 */ }) ，将数据发送到父组件
4. 在父组件的 js 中，通过 e.detail 获取到子组件传递过来的数据

步骤1：在父组件的 js 中，定义一个函数，这个函数即将通过自定义事件的形式，传递给子组件。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689639353539-53e96921-cf31-4aac-b1af-34fde0ce932d.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=277&id=u05824e73&originHeight=277&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17882&status=done&style=none&taskId=u478152a5-1944-496a-8e90-36102f05ccd&title=&width=943)<br />步骤2：在父组件的 wxml 中，通过自定义事件的形式，将步骤 1 中定义的函数引用，传递给子组件。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689639365101-ff99e28c-7fcc-46db-9175-a17f002a9e08.png#averageHue=%230d1223&clientId=ubfe5c909-99ad-4&from=paste&height=240&id=u292951f1&originHeight=240&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22142&status=done&style=none&taskId=u4df73c24-41d3-4d42-b412-629a5a07c46&title=&width=943)<br />步骤3：在子组件的 js 中，通过调用 this.triggerEvent(‘自定义事件名称’, { /* 参数对象 */ }) ，将数据发送到父组件。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689639382937-294e7e4e-f045-4175-9fd3-063cab0f1d3e.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=574&id=ube5f071a&originHeight=574&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32198&status=done&style=none&taskId=ub2e61f1b-936f-42ba-9ad8-0de47b15633&title=&width=943)<br />步骤4：在父组件的 js 中，通过 e.detail 获取到子组件传递过来的数据。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689639442837-3ea9684a-3382-4328-bddd-6c5cf221a802.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=315&id=uc7432e49&originHeight=315&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12515&status=done&style=none&taskId=ue4d39a38-70da-4c88-af41-9eb89715f01&title=&width=943)
<a name="AS5pp"></a>

#### 4. 获取组件实例

可在父组件里调用 this.selectComponent("id或class选择器") ，获取子组件的实例对象，从而直接访问子组件的任意数据和方法。调用时需要传入一个选择器，例如 this.selectComponent(".my-component")。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689639486672-708606e8-cd08-4f45-b4f5-bc831a32319a.png#averageHue=%230c1122&clientId=ubfe5c909-99ad-4&from=paste&height=500&id=ubf617d2d&originHeight=500&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49350&status=done&style=none&taskId=u308237f8-c7bf-4f9d-9a49-da107ca87c4&title=&width=943)
<a name="KsBpO"></a>

### behaviors

<a name="WRu4g"></a>

#### 1. 什么是 behaviors

behaviors 是小程序中，用于**实现组件间代码共享**的特性，类似于 Vue.js 中的 “mixins”。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689639531414-a009a208-881b-4854-b358-13aaca2bc464.png#averageHue=%23fcfcfc&clientId=ubfe5c909-99ad-4&from=paste&height=252&id=u62fa4f69&originHeight=252&originWidth=447&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15062&status=done&style=none&taskId=u59e07598-9e9a-4cd2-bef3-797127128cc&title=&width=447)
<a name="zj2T3"></a>

#### 2. behaviors 的工作方式

每个 behavior 可以包含一组属性、数据、生命周期函数和方法。组件引用它时，它的属性、数据和方法会被合并到组件中。<br />每个组件可以引用多个 behavior，behavior 也可以引用其它 behavior。
<a name="SD7hO"></a>

#### 3. 创建 behavior

调用 Behavior(Object object) 方法即可创建一个共享的 behavior 实例对象，供所有的组件使用：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689639562135-c0304714-3200-4da9-b749-12c22212ea55.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=500&id=u89fd0677&originHeight=500&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32486&status=done&style=none&taskId=u82667be7-3be8-4504-8b65-95fe4f7ca80&title=&width=943)
<a name="wt1x9"></a>

#### 4. 导入并使用 behavior

在组件中，使用 require() 方法导入需要的 behavior，挂载后即可访问 behavior 中的数据或方法，示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689639576679-e6b97f3e-02ab-4772-97bd-65e252a6ba78.png#averageHue=%230c1022&clientId=ubfe5c909-99ad-4&from=paste&height=389&id=u04b91230&originHeight=389&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27757&status=done&style=none&taskId=u75124521-2d37-4612-91e8-d7b4372ceb5&title=&width=943)
<a name="ohVYz"></a>

#### 5. behavior 中所有可用的节点

| **可用的节点** | **类型**     | **是否必填** | **描述**            |
| -------------- | ------------ | ------------ | ------------------- |
| properties     | Object Map   | 否           | 同组件的属性        |
| data           | Object       | 否           | 同组件的数据        |
| methods        | Object       | 否           | 同自定义组件的方法  |
| behaviors      | String Array | 否           | 引入其它的 behavior |
| created        | Function     | 否           | 生命周期函数        |
| attached       | Function     | 否           | 生命周期函数        |
| ready          | Function     | 否           | 生命周期函数        |
| moved          | Function     | 否           | 生命周期函数        |
| detached       | Function     | 否           | 生命周期函数        |

<a name="LlQzW"></a>

#### 6. 同名字段的覆盖和组合规则*

组件和它引用的 behavior 中可以包含同名的字段，此时可以参考如下 3 种同名时的处理规则：

1. 同名的数据字段 (data)
2. 同名的属性 (properties) 或方法 (methods)
3. 同名的生命周期函数

关于详细的覆盖和组合规则，大家可以参考微信小程序官方文档给出的说明：<br />[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html)
<a name="d3Fi0"></a>

## 使用 npm 包

小程序对 npm 的支持与限制<br />目前，小程序中已经支持使用 npm 安装第三方包，从而来提高小程序的开发效率。但是，在小程序中使用 npm 包有如下 3 个限制：

1. 不支持依赖于 Node.js 内置库的包
2. 不支持依赖于浏览器内置对象（window）的包
3. 不支持依赖于 C++ 插件的包

总结：虽然 npm 上的包有千千万，但是能供小程序使用的包却“为数不多”。
<a name="DNPT7"></a>

### Vant Weapp

<a name="H7WPB"></a>

#### 1.简介

Vant Weapp 是有赞前端团队开源的一套小程序 UI 组件库，助力开发者快速搭建小程序应用。它所使用的是 MIT 开源许可协议，对商业使用比较友好。<br />官方文档地址 [https://youzan.github.io/vant-weapp](https://youzan.github.io/vant-weapp)

扫描下方的小程序二维码，体验组件库示例：
<a name="KtjQQ"></a>

#### 2. 安装 Vant 组件库

在小程序项目中，安装 Vant 组件库主要分为如下 3 步：

1. 通过 npm 安装（建议指定版本为@1.3.3）
2. 构建 npm 包
3. 修改 app.json

详细的操作步骤，大家可以参考 Vant 官方提供的快速上手教程：<br />[https://youzan.github.io/vant-weapp/#/quickstart#an-zhuang](https://youzan.github.io/vant-weapp/#/quickstart#an-zhuang)
<a name="UWAfU"></a>

#### 3. 使用 Vant 组件

安装完 Vant 组件库之后，可以在 app.json(全局引入) 的 usingComponents 节点中引入需要的组件，即可在 wxml 中直接使用组件。示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689643699019-7a20bb01-716c-4140-8481-f16cc71ac7db.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=351&id=u1a3fe70a&originHeight=351&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17766&status=done&style=none&taskId=u120deb47-2cac-40a6-975e-5358044200e&title=&width=943)
<a name="D9DrN"></a>

#### 4. 定制全局主题样式

Vant Weapp 使用 CSS 变量来实现定制主题。 关于 CSS 变量的基本用法，请参考 MDN 文档：<br />[https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties)<br />在 app.wxss 中，写入 CSS 变量，即可对全局生效：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689643782577-974a8640-f382-4e61-9a16-dde3a461bb4e.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=315&id=ubdd62ee6&originHeight=315&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18309&status=done&style=none&taskId=u4856c3af-5518-4c92-9e7e-6e7fedaae78&title=&width=943)<br />所有可用的颜色变量，请参考 Vant 官方提供的配置文件：[https://github.com/youzan/vant-weapp/blob/dev/packages/common/style/var.less](https://github.com/youzan/vant-weapp/blob/dev/packages/common/style/var.less)
<a name="VgJbO"></a>

### API Promise化

<a name="K1Y9t"></a>

#### 1. 基于回调函数的异步 API 的缺点

默认情况下，小程序官方提供的异步 API 都是基于回调函数实现的，例如，网络请求的 API 需要按照如下的方式调用：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689643954489-ce11182f-a6e9-4b3e-9ca9-1908173261c2.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=389&id=u06621426&originHeight=389&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23875&status=done&style=none&taskId=uee3e99e6-75f9-44f3-bb24-0a49d645276&title=&width=943)<br />缺点：容易造成回调地狱的问题，代码的可读性、维护性差！
<a name="KS9VX"></a>

#### 2. 什么是 API Promise 化

API Promise化，指的是通过额外的配置，将官方提供的、基于回调函数的异步 API，升级改造为基于 Promise 的异步 API，从而提高代码的可读性、维护性，避免回调地狱的问题。
<a name="dGPGx"></a>

#### 3. 实现 API Promise 化

在小程序中，实现 API Promise 化主要依赖于 miniprogram-api-promise 这个第三方的 npm 包。它的安装和使用步骤如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689643999435-aa359e35-b681-4112-9a86-f880a89cf50d.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=130&id=u74749219&originHeight=130&originWidth=936&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6248&status=done&style=none&taskId=u0ada9711-0f27-4bc4-be90-067d343e91e&title=&width=936)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689644003875-626d0beb-8197-4676-941b-0dc3697b9a8c.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=351&id=uf9276235&originHeight=351&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24369&status=done&style=none&taskId=u9b6cc7e9-968d-440d-a303-45788979c7f&title=&width=943)
<a name="iKFEj"></a>

#### 4. 调用 Promise 化之后的异步 API

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689644020948-03b57974-5f15-47c4-92b8-03d615ef35f4.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=574&id=ueba2cb56&originHeight=574&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36106&status=done&style=none&taskId=uc4c52d43-99c4-44ce-826c-5ed64208762&title=&width=943)
<a name="KNDIV"></a>

## 全局数据共享

<a name="eeybN"></a>

### 1. 什么是全局数据共享

全局数据共享（又叫做：状态管理）是为了解决组件之间数据共享的问题。<br />开发中常用的全局数据共享方案有：Vuex、Redux、MobX 等。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689649742635-125167f5-494a-4862-aa63-3cd2ffb82f27.png#averageHue=%23efefed&clientId=ubfe5c909-99ad-4&from=paste&height=447&id=u42d1fe13&originHeight=447&originWidth=800&originalType=binary&ratio=1&rotation=0&showTitle=false&size=199916&status=done&style=none&taskId=ufaa6c349-2a3e-4020-8af4-5d7315e7ff1&title=&width=800)
<a name="oszzZ"></a>

### 2. 小程序中的全局数据共享方案

在小程序中，可使用 mobx-miniprogram 配合 mobx-miniprogram-bindings 实现全局数据共享。其中：

- mobx-miniprogram 用来创建 Store 实例对象
- mobx-miniprogram-bindings 用来把 Store 中的共享数据或方法，绑定到组件或页面中使用
  <a name="J24JV"></a>

### MobX

<a name="USBkm"></a>

#### 1. 安装 MobX 相关的包

在项目中运行如下的命令，安装 MobX 相关的包：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689655509007-bd8eb772-789f-4055-8af3-8ae394d2cf05.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=130&id=u976ef25d&originHeight=130&originWidth=936&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7309&status=done&style=none&taskId=u8725b1e0-d65e-4694-b660-66d1373e864&title=&width=936)<br />注意：MobX 相关的包安装完毕之后，记得删除 miniprogram_npm 目录后，重新构建 npm。
<a name="bXAUb"></a>

#### 2. 创建 MobX 的 Store 实例

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689655529008-7a8d69fd-8714-438d-b49a-8468f95e25a5.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=759&id=u666feb4c&originHeight=759&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39507&status=done&style=none&taskId=u373f2183-3a37-4e8e-b56c-34cc6d25450&title=&width=943)<br />get是计算属性的关键字。。。<br />action是传进来的函数，进行创建action。。
<a name="HuEoi"></a>

#### 3. 将 Store 中的成员绑定到页面中

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689655552858-ffeb0695-00b0-414a-aa61-6acb18e5de28.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=685&id=udbd9c827&originHeight=685&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42263&status=done&style=none&taskId=u5801c78a-60c1-4471-9c7c-0d1be014a6d&title=&width=943)
<a name="beraq"></a>

#### 4. 在页面上使用 Store 中的成员

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689655562243-44a6b4b7-d935-4f54-9982-81606f638f37.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=574&id=u8f0a3458&originHeight=574&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35556&status=done&style=none&taskId=u3342b8b4-b8c5-495d-80a9-7c77dbcf3bb&title=&width=943)
<a name="rVvme"></a>

#### 5. 将 Store 中的成员绑定到组件中

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689655573136-f01d5822-3eff-44d0-b940-c2d16c9c7207.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=759&id=u064788c0&originHeight=759&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=56302&status=done&style=none&taskId=ub1a58ee0-9384-43e7-99ef-9c24694af04&title=&width=943)
<a name="zddLO"></a>

#### 6. 在组件中使用 Store 中的成员

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689655582630-3b2d8d06-cc17-4365-b110-f4eb36744c2f.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=647&id=uea6578bd&originHeight=647&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36750&status=done&style=none&taskId=u4e459aa6-8944-4489-b93e-8deb76ccd5c&title=&width=943)
<a name="RtjXf"></a>

## 分包

<a name="W4fd0"></a>

### 基础概念

<a name="JNyt3"></a>

#### 1. 什么是分包

分包指的是把一个完整的小程序项目，按照需求划分为不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。
<a name="PKfmj"></a>

#### 2. 分包的好处

对小程序进行分包的好处主要有以下两点：

- 可以优化小程序首次启动的下载时间
- 在多团队共同开发时可以更好的解耦协作
  <a name="BWlxE"></a>

#### 3. 分包前项目的构成

分包前，小程序项目中所有的页面和资源都被打包到了一起，导致整个项目体积过大，影响小程序首次启动的下载时间。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689655639930-1fad0dc2-17d7-453f-b40d-ac2163fab273.png#averageHue=%23fcefe6&clientId=ubfe5c909-99ad-4&from=paste&height=293&id=u3d1c9d2a&originHeight=293&originWidth=710&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24848&status=done&style=none&taskId=u55550e33-3ce7-4d2a-811a-66dc33a794f&title=&width=710)
<a name="N43SR"></a>

#### 4. 分包后项目的构成

分包后，小程序项目由 1 个主包 + 多个分包组成：

- 主包：一般只包含项目的启动页面或 TabBar 页面、以及所有分包都需要用到的一些公共资源
- 分包：只包含和当前分包有关的页面和私有资源

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689655806037-b25958b9-56e9-4a6b-9493-ac9d65c8c136.png#averageHue=%23fcf7f4&clientId=ubfe5c909-99ad-4&from=paste&height=434&id=u3c351c67&originHeight=434&originWidth=1405&originalType=binary&ratio=1&rotation=0&showTitle=false&size=57759&status=done&style=none&taskId=ue1aa4029-54d3-4d34-b951-14eb0a27634&title=&width=1405)
<a name="kMUIa"></a>

#### 5. 分包的加载规则

- 在小程序启动时，默认会下载主包并启动主包内页面
  - tabBar 页面需要放到主包中
- 当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示
  - 非 tabBar 页面可以按照功能的不同，划分为不同的分包之后，进行按需下载
    <a name="R0MTl"></a>

#### 6. 分包的体积限制

目前，小程序分包的大小有以下两个限制：<br />整个小程序所有分包大小不超过 16M（主包 + 所有分包）<br />单个分包/主包大小不能超过 2M
<a name="ULGNs"></a>

### 使用分包

<a name="J0wZx"></a>

#### 1. 配置方法

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689655862385-b23e88e8-eb48-4785-894e-2dcea50e9b06.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=647&id=u8184b736&originHeight=647&originWidth=477&originalType=binary&ratio=1&rotation=0&showTitle=false&size=37005&status=done&style=none&taskId=u14bd3576-8adc-4a07-99e6-b8ffd30d9fb&title=&width=477)![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689655869036-d6112cd2-03b7-402f-be82-5555547b3e29.png#averageHue=%23470000&clientId=ubfe5c909-99ad-4&from=paste&height=64&id=u1752ce4e&originHeight=64&originWidth=66&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1605&status=done&style=none&taskId=ub059631f-4726-4a20-9e1e-5d2cf668a96&title=&width=66)![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689655873621-bac3ae1e-d4b2-4576-8d6a-0d98ae40afed.png#averageHue=%230c1122&clientId=ubfe5c909-99ad-4&from=paste&height=679&id=uc8706cd7&originHeight=906&originWidth=671&originalType=binary&ratio=1&rotation=0&showTitle=false&size=70654&status=done&style=none&taskId=u32b58cc3-3b3a-4751-bf15-a90f0aec6ad&title=&width=503)
<a name="ka5a2"></a>

#### 2. 打包原则

1. 小程序会按 subpackages 的配置进行分包，subpackages 之外的目录将被打包到主包中
2. 主包也可以有自己的 pages（即最外层的 pages 字段）
3. tabBar 页面必须在主包内
4. 分包之间不能互相嵌套
   <a name="jXpiI"></a>

#### 3. 引用原则

1. 主包无法引用分包内的私有资源
2. 分包之间不能相互引用私有资源
3. 分包可以引用主包内的公共资源

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689655925356-ffd62272-8d94-4c7c-9433-dad6dfb8b916.png#averageHue=%23fcf7f4&clientId=ubfe5c909-99ad-4&from=paste&height=434&id=ub568390b&originHeight=434&originWidth=1405&originalType=binary&ratio=1&rotation=0&showTitle=false&size=57759&status=done&style=none&taskId=u46de0da5-4d53-4181-adf5-7443595b095&title=&width=1405)
<a name="tn265"></a>

### 独立分包

<a name="YADWL"></a>

#### 1. 什么是独立分包

独立分包本质上也是分包，只不过它比较特殊，可以独立于主包和其他分包而单独运行。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689655960162-df513656-27e5-421d-9741-9d50d99194cd.png#averageHue=%23acf1ac&clientId=ubfe5c909-99ad-4&from=paste&height=307&id=u5884c663&originHeight=307&originWidth=798&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26702&status=done&style=none&taskId=u65097223-d471-4ef4-9209-550f53b76b6&title=&width=798)
<a name="BrRPO"></a>

#### 2. 独立分包和普通分包的区别

最主要的区别：是否依赖于主包才能运行

- 普通分包必须依赖于主包才能运行
- 独立分包可以在不下载主包的情况下，独立运行
  <a name="YJLfk"></a>

#### 3. 独立分包的应用场景

开发者可以按需，将某些具有一定功能独立性的页面配置到独立分包中。原因如下：

- 当小程序从普通的分包页面启动时，需要首先下载主包
- 而独立分包不依赖主包即可运行，可以很大程度上提升分包页面的启动速度

注意：一个小程序中可以有多个独立分包。
<a name="R4R0O"></a>

#### 4. 独立分包的配置方法

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689656020164-a94d4bb8-11ac-4af9-a0d9-872df5ecb252.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=647&id=u5086afc5&originHeight=647&originWidth=397&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31634&status=done&style=none&taskId=u6bdf1033-cce9-4eb2-beb1-a84a585fca9&title=&width=397)![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689656023344-62d803fc-df95-4f2b-8119-59b59cee6f3d.png#averageHue=%23470000&clientId=ubfe5c909-99ad-4&from=paste&height=64&id=u4e51a94b&originHeight=64&originWidth=66&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1605&status=done&style=none&taskId=u01644df8-4bca-4e26-b26c-91d41830cda&title=&width=66)![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689656029839-1f796f9d-ff04-4f2f-9691-40e33bef1ee5.png#averageHue=%230c1021&clientId=ubfe5c909-99ad-4&from=paste&height=453&id=ucfd07a8e&originHeight=906&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=53446&status=done&style=none&taskId=u9c5c2bec-88db-49f0-af5d-904d16a1d1c&title=&width=472)
<a name="ygXjd"></a>

#### 5. 引用原则

独立分包和普通分包以及主包之间，是相互隔绝的，不能相互引用彼此的资源！例如：

1. 主包无法引用独立分包内的私有资源
2. 独立分包之间，不能相互引用私有资源
3. 独立分包和普通分包之间，不能相互引用私有资源
4. 特别注意：独立分包中不能引用主包内的公共资源
   <a name="oKGHr"></a>

### 分包预下载

<a name="A6eh1"></a>

#### 1. 什么是分包预下载

分包预下载指的是：在进入小程序的某个页面时，由框架自动预下载可能需要的分包，从而提升进入后续分包页面时的启动速度。
<a name="SuLfM"></a>

#### 2. 配置分包的预下载

预下载分包的行为，会在进入指定的页面时触发。在 app.json 中，使用 preloadRule 节点定义分包的预下载规则，示例代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689656079494-5934e393-5a18-46aa-a5d7-2fcbb9dc31f8.png#averageHue=%230c1122&clientId=ubfe5c909-99ad-4&from=paste&height=574&id=u44a4089a&originHeight=574&originWidth=1101&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45626&status=done&style=none&taskId=u5c7ddfa3-b640-43ba-9646-31c3123633b&title=&width=1101)
<a name="uRWvD"></a>

#### 3. 分包预下载的限制

同一个分包中的页面享有共同的预下载大小限额 2M，例如：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1689656098360-6b1ed457-6ca4-4eef-a328-c385fde474b0.png#averageHue=%23cbc4b9&clientId=ubfe5c909-99ad-4&from=paste&height=353&id=uf39e3e14&originHeight=353&originWidth=917&originalType=binary&ratio=1&rotation=0&showTitle=false&size=62839&status=done&style=none&taskId=u2f551206-5e9d-46c7-8580-4de68e582fb&title=&width=917)
